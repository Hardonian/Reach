[{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\adapters-runtime-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\agents-cli.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\agents-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\analyze-pr-cli.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\analyze-pr-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\audit-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\audit-drift-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\benchmark-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\cache-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\controlplane-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\dek-replay-cli.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'readFileSync' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":10,"messageId":"unusedVar","endLine":9,"endColumn":22,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"readFileSync"},"fix":{"range":[210,223],"text":""},"desc":"Remove unused variable \"readFileSync\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'resolve' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":10,"messageId":"unusedVar","endLine":10,"endColumn":17,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"resolve"},"fix":{"range":[289,297],"text":""},"desc":"Remove unused variable \"resolve\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @ts-nocheck\r\n/**\r\n * DEK Replay CLI - Deterministic Execution Kernel Replay\r\n *\r\n * Provides zeo replay <run-id> functionality for verifying\r\n * deterministic execution and detecting drift.\r\n */\r\n\r\nimport { readFileSync, writeFileSync, existsSync, mkdirSync } from \"node:fs\";\r\nimport { resolve, join } from \"node:path\";\r\nimport type { ZeoJournalEntry } from \"@zeo/contracts\";\r\nimport {\r\n  replayExecution,\r\n  getJournalEntry,\r\n  initializeDEK,\r\n} from \"@zeo/kernel\";\r\n\r\nexport interface DekReplayArgs {\r\n  runId: string;\r\n  json: boolean;\r\n  strict: boolean;\r\n  suggestModel: boolean;\r\n  reportOut?: string;\r\n}\r\n\r\nexport function parseDekReplayArgs(argv: string[]): DekReplayArgs | null {\r\n  if (argv.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  const args: DekReplayArgs = {\r\n    runId: argv[0],\r\n    json: argv.includes(\"--json\"),\r\n    strict: !argv.includes(\"--no-strict\"),\r\n    suggestModel: argv.includes(\"--suggest-model\"),\r\n  };\r\n\r\n  const reportIdx = argv.indexOf(\"--report-out\");\r\n  if (reportIdx !== -1 && argv[reportIdx + 1]) {\r\n    args.reportOut = argv[reportIdx + 1];\r\n  }\r\n\r\n  return args;\r\n}\r\n\r\nexport async function runDekReplayCommand(args: DekReplayArgs): Promise<number> {\r\n  // Initialize DEK\r\n  initializeDEK();\r\n\r\n  if (!args.json) {\r\n    console.log(`\\n=== Zeo DEK Replay ===`);\r\n    console.log(`Run ID: ${args.runId}`);\r\n    console.log(`Mode: ${args.strict ? \"strict\" : \"permissive\"}`);\r\n    console.log(`\\nReconstructing execution context...`);\r\n  }\r\n\r\n  // Execute replay\r\n  const replayResult = await replayExecution(args.runId, {\r\n    strictModelMatch: args.strict,\r\n  });\r\n\r\n  const { status, originalEntry } = replayResult;\r\n\r\n  if (!originalEntry) {\r\n    if (args.json) {\r\n      console.log(\r\n        JSON.stringify(\r\n          {\r\n            status: \"UNAVAILABLE\",\r\n            error: `Run ID ${args.runId} not found in journal`,\r\n          },\r\n          null,\r\n          2,\r\n        ),\r\n      );\r\n    } else {\r\n      console.error(`\\nError: Run ID ${args.runId} not found in journal.`);\r\n      console.log(`\\nTo list available runs:`);\r\n      console.log(`  zeo journal list`);\r\n    }\r\n    return 1;\r\n  }\r\n\r\n  // Format output\r\n  if (args.json) {\r\n    const output = formatJsonOutput(replayResult);\r\n    console.log(JSON.stringify(output, null, 2));\r\n  } else {\r\n    printHumanOutput(\r\n      {\r\n        status: replayResult.status,\r\n        originalEntry: replayResult.originalEntry,\r\n        replayResult: replayResult.replayResult,\r\n        comparison: replayResult.comparison,\r\n        modelAvailability: replayResult.modelAvailability || {\r\n          available: true,\r\n        },\r\n      },\r\n      args.suggestModel,\r\n    );\r\n  }\r\n\r\n  // Write report if requested\r\n  if (args.reportOut) {\r\n    writeReport(args.reportOut, replayResult);\r\n  }\r\n\r\n  // Exit code based on status\r\n  switch (status) {\r\n    case \"MATCH\":\r\n      return 0;\r\n    case \"MISMATCH\":\r\n      return 2;\r\n    case \"DEGRADED\":\r\n      return 3;\r\n    case \"UNAVAILABLE\":\r\n      return 1;\r\n    default:\r\n      return 1;\r\n  }\r\n}\r\n\r\nfunction formatJsonOutput(result: {\r\n  status: \"MATCH\" | \"MISMATCH\" | \"DEGRADED\" | \"UNAVAILABLE\";\r\n  originalEntry: ZeoJournalEntry | undefined;\r\n  comparison: {\r\n    originalHash: string;\r\n    replayHash: string;\r\n    match: boolean;\r\n  };\r\n}): unknown {\r\n  if (!result.originalEntry) {\r\n    return {\r\n      status: result.status,\r\n      error: \"Original entry not found\",\r\n    };\r\n  }\r\n\r\n  return {\r\n    status: result.status,\r\n    original: {\r\n      runId: result.originalEntry.envelope.runId,\r\n      workflowId: result.originalEntry.envelope.workflowId,\r\n      timestamp: result.originalEntry.envelope.timestamp,\r\n      outputHash: result.originalEntry.outputHash,\r\n      modelSpec: result.originalEntry.envelope.modelSpec,\r\n      durationMs: result.originalEntry.durationMs,\r\n      status: result.originalEntry.status,\r\n    },\r\n    comparison: result.comparison,\r\n    timestamp: new Date().toISOString(),\r\n  };\r\n}\r\n\r\nfunction printHumanOutput(\r\n  result: {\r\n    status: \"MATCH\" | \"MISMATCH\" | \"DEGRADED\" | \"UNAVAILABLE\";\r\n    originalEntry: ZeoJournalEntry | undefined;\r\n    replayResult: {\r\n      outputHash: string;\r\n      durationMs: number;\r\n    };\r\n    comparison: {\r\n      originalHash: string;\r\n      replayHash: string;\r\n      match: boolean;\r\n    };\r\n    modelAvailability: {\r\n      available: boolean;\r\n      suggestedModel?: string;\r\n    };\r\n  },\r\n  showSuggestions: boolean,\r\n): void {\r\n  if (!result.originalEntry) return;\r\n\r\n  const envelope = result.originalEntry.envelope;\r\n\r\n  console.log(`\\nOriginal Execution:`);\r\n  console.log(`  Run ID: ${envelope.runId}`);\r\n  console.log(`  Workflow: ${envelope.workflowId}`);\r\n  console.log(`  Timestamp: ${envelope.timestamp}`);\r\n  console.log(`  Model: ${envelope.modelSpec.provider}/${envelope.modelSpec.model}`);\r\n  console.log(`  Duration: ${result.originalEntry.durationMs}ms`);\r\n\r\n  console.log(`\\nReplay Comparison:`);\r\n  console.log(`  Original Hash: ${result.comparison.originalHash.slice(0, 16)}...`);\r\n  console.log(\r\n    `  Replay Hash: ${\r\n      result.comparison.replayHash === \"reconstruction_required\"\r\n        ? \"N/A (reconstruction required)\"\r\n        : result.comparison.replayHash.slice(0, 16) + \"...\"\r\n    }`,\r\n  );\r\n\r\n  console.log(`\\nStatus: ${result.status}`);\r\n\r\n  switch (result.status) {\r\n    case \"MATCH\":\r\n      console.log(`  ✅ Execution is deterministic - outputs match exactly`);\r\n      break;\r\n    case \"MISMATCH\":\r\n      console.log(`  ❌ Drift detected - outputs differ`);\r\n      console.log(`  \\nThis indicates:`);\r\n      console.log(`  - Non-deterministic model behavior`);\r\n      console.log(`  - External dependency changes`);\r\n      console.log(`  - Policy or configuration drift`);\r\n      break;\r\n    case \"DEGRADED\":\r\n      console.log(`  ⚠️  Replay degraded - input reconstruction required`);\r\n      console.log(`  \\nThe original input snapshot needs to be restored for full replay.`);\r\n      break;\r\n    case \"UNAVAILABLE\":\r\n      console.log(`  ❌ Model unavailable for replay`);\r\n      if (showSuggestions && result.modelAvailability.suggestedModel) {\r\n        console.log(`  \\nSuggested compatible model: ${result.modelAvailability.suggestedModel}`);\r\n      }\r\n      break;\r\n  }\r\n\r\n  console.log(`\\nDeterminism Check:`);\r\n  console.log(`  Input Hash: ${envelope.inputHash.slice(0, 16)}...`);\r\n  console.log(`  Model Spec Hash: ${envelope.modelSpecHash.slice(0, 16)}...`);\r\n  console.log(`  Policy Hash: ${envelope.policyHash.slice(0, 16)}...`);\r\n  console.log(`  Seed: ${envelope.deterministicSeed.slice(0, 16)}...`);\r\n}\r\n\r\nfunction writeReport(\r\n  outDir: string,\r\n  result: {\r\n    status: \"MATCH\" | \"MISMATCH\" | \"DEGRADED\" | \"UNAVAILABLE\";\r\n    originalEntry: ZeoJournalEntry | undefined;\r\n    comparison: {\r\n      originalHash: string;\r\n      replayHash: string;\r\n      match: boolean;\r\n    };\r\n  },\r\n): void {\r\n  if (!existsSync(outDir)) {\r\n    mkdirSync(outDir, { recursive: true });\r\n  }\r\n\r\n  const reportPath = join(outDir, `replay-report-${Date.now()}.json`);\r\n  writeFileSync(reportPath, JSON.stringify(formatJsonOutput(result), null, 2));\r\n  console.log(`\\nReport written to: ${reportPath}`);\r\n}\r\n\r\n/** List available runs in journal */\r\nexport async function listJournalRuns(limit: number = 20): Promise<void> {\r\n  const { readJournalEntries } = await import(\"@zeo/kernel\");\r\n  const entries = readJournalEntries().slice(-limit);\r\n\r\n  console.log(`\\n=== Recent Journal Entries ===`);\r\n  console.log(`Showing last ${entries.length} runs:\\n`);\r\n\r\n  for (const entry of entries.reverse()) {\r\n    const e = entry.envelope;\r\n    const status = entry.status === \"success\" ? \"✓\" : entry.status === \"error\" ? \"✗\" : \"◐\";\r\n    console.log(`${status} ${e.runId}`);\r\n    console.log(`   Workflow: ${e.workflowId}`);\r\n    console.log(`   Time: ${e.timestamp}`);\r\n    console.log(`   Model: ${e.modelSpec.provider}/${e.modelSpec.model}`);\r\n    console.log(`   Hash: ${entry.outputHash.slice(0, 16)}...`);\r\n    console.log();\r\n  }\r\n}\r\n\r\n/** Export for integration with main CLI */\r\nexport { replayExecution, getJournalEntry };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\doctor-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\doctor-dek-checks.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":11,"messageId":"unexpectedAny","endLine":104,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3052,3055],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3052,3055],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":112,"column":45,"messageId":"unexpectedAny","endLine":112,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3411,3414],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3411,3414],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { loadConfig } from \"../core/env.js\";\n// @ts-nocheck\n// DEK-specific checks\nimport { readFileSync, existsSync, readdirSync } from \"node:fs\";\nimport { resolve, join } from \"node:path\";\nimport type { DoctorCheck } from \"./doctor-cli.js\";\n\nexport function runDekJournalCheck(): DoctorCheck {\n  const journalDir = resolve(process.cwd(), \".zeo\", \"journal\");\n\n  if (!existsSync(journalDir)) {\n    return {\n      id: \"dek-journal\",\n      name: \"DEK Journal Health\",\n      status: \"pass\",\n      message: \"Journal directory not yet created (will be created on first run)\",\n    };\n  }\n\n  try {\n    const files = readdirSync(journalDir).filter((f) => f.endsWith(\".jsonl\"));\n\n    if (files.length === 0) {\n      return {\n        id: \"dek-journal\",\n        name: \"DEK Journal Health\",\n        status: \"pass\",\n        message: \"No journal entries yet\",\n      };\n    }\n\n    // Check latest journal file for corruption\n    const latestFile = files.sort().reverse()[0];\n    const content = readFileSync(join(journalDir, latestFile), \"utf8\");\n    const lines = content.trim().split(\"\\n\").filter(Boolean);\n\n    let corruptLines = 0;\n    for (const line of lines.slice(-10)) {\n      try {\n        JSON.parse(line);\n      } catch {\n        corruptLines++;\n      }\n    }\n\n    if (corruptLines > 0) {\n      return {\n        id: \"dek-journal\",\n        name: \"DEK Journal Health\",\n        status: \"warning\",\n        message: `${files.length} journal file(s), ${corruptLines} corrupt line(s) in latest`,\n        remediation: \"Journal may be corrupted. Backup and recreate if needed.\",\n      };\n    }\n\n    return {\n      id: \"dek-journal\",\n      name: \"DEK Journal Health\",\n      status: \"pass\",\n      message: `${files.length} journal file(s), ${lines.length} total entries`,\n      details: { files: files.length, entries: lines.length },\n    };\n  } catch (err) {\n    return {\n      id: \"dek-journal\",\n      name: \"DEK Journal Health\",\n      status: \"warning\",\n      message: `Cannot read journal: ${(err as Error).message}`,\n    };\n  }\n}\n\nexport function runModelAdapterCheck(): DoctorCheck {\n  // Check for registered model adapters in kernel\n  try {\n    // This would typically check the actual adapter registry\n    // For now, we check if adapter configuration exists\n    const adapterConfigPath = resolve(process.cwd(), \".zeo\", \"adapters.json\");\n\n    if (!existsSync(adapterConfigPath)) {\n      return {\n        id: \"model-adapters\",\n        name: \"Model Adapter Integrity\",\n        status: \"pass\",\n        message: \"Using default model adapters\",\n      };\n    }\n\n    const config = JSON.parse(readFileSync(adapterConfigPath, \"utf8\"));\n    const adapters = config.adapters || [];\n\n    if (adapters.length === 0) {\n      return {\n        id: \"model-adapters\",\n        name: \"Model Adapter Integrity\",\n        status: \"warning\",\n        message: \"No model adapters configured\",\n        remediation: \"Add adapters to .zeo/adapters.json or use defaults\",\n      };\n    }\n\n    // Check each adapter has required fields\n    const validAdapters = adapters.filter(\n      (a: any) => a.id && a.provider && a.model && typeof a.execute === \"function\",\n    );\n\n    return {\n      id: \"model-adapters\",\n      name: \"Model Adapter Integrity\",\n      status: validAdapters.length === adapters.length ? \"pass\" : \"warning\",\n      message: `${validAdapters.length}/${adapters.length} adapters valid`,\n      details: { adapters: adapters.map((a: any) => a.id) },\n    };\n  } catch (err) {\n    return {\n      id: \"model-adapters\",\n      name: \"Model Adapter Integrity\",\n      status: \"warning\",\n      message: `Adapter check failed: ${(err as Error).message}`,\n    };\n  }\n}\n\nexport function runPolicySchemaCheck(): DoctorCheck {\n  const policyPath = resolve(process.cwd(), \".zeo\", \"policy.json\");\n\n  // Default policy version\n  const currentSchemaVersion = \"1.0.0\";\n\n  if (!existsSync(policyPath)) {\n    return {\n      id: \"policy-schema\",\n      name: \"Policy Schema Version\",\n      status: \"pass\",\n      message: `Using default policy schema v${currentSchemaVersion}`,\n      details: {\n        current: currentSchemaVersion,\n        latest: currentSchemaVersion,\n        compatible: true,\n      },\n    };\n  }\n\n  try {\n    const policy = JSON.parse(readFileSync(policyPath, \"utf8\"));\n    const policyVersion = policy.schemaVersion || policy.version || \"unknown\";\n\n    // Simple semver comparison\n    const isCompatible = policyVersion.startsWith(\"1.\");\n\n    if (!isCompatible) {\n      return {\n        id: \"policy-schema\",\n        name: \"Policy Schema Version\",\n        status: \"warning\",\n        message: `Policy schema v${policyVersion} may be incompatible (expected v1.x)`,\n        remediation: \"Update policy schema to v1.0.0 or check migration guide\",\n        details: {\n          current: policyVersion,\n          latest: currentSchemaVersion,\n          compatible: false,\n        },\n      };\n    }\n\n    return {\n      id: \"policy-schema\",\n      name: \"Policy Schema Version\",\n      status: \"pass\",\n      message: `Policy schema v${policyVersion} compatible`,\n      details: {\n        current: policyVersion,\n        latest: currentSchemaVersion,\n        compatible: true,\n      },\n    };\n  } catch (err) {\n    return {\n      id: \"policy-schema\",\n      name: \"Policy Schema Version\",\n      status: \"fail\",\n      message: `Invalid policy.json: ${(err as Error).message}`,\n      remediation: \"Fix or remove .zeo/policy.json\",\n    };\n  }\n}\n\nexport async function runEnterpriseConnectivityCheck(): Promise<DoctorCheck> {\n  const supabaseUrl = loadConfig().SUPABASE_URL;\n\n  if (!supabaseUrl) {\n    return {\n      id: \"enterprise\",\n      name: \"Enterprise Connectivity (Supabase)\",\n      status: \"pass\",\n      message: \"Enterprise mode not configured (local-only mode)\",\n      details: { status: \"unconfigured\" },\n    };\n  }\n\n  const supabaseKey = loadConfig().SUPABASE_SERVICE_KEY;\n  if (!supabaseKey) {\n    return {\n      id: \"enterprise\",\n      name: \"Enterprise Connectivity (Supabase)\",\n      status: \"warning\",\n      message: \"SUPABASE_URL set but SUPABASE_SERVICE_KEY missing\",\n      remediation: \"Set SUPABASE_SERVICE_KEY environment variable\",\n      details: { status: \"misconfigured\" },\n    };\n  }\n\n  // Test connectivity\n  try {\n    const startTime = Date.now();\n    const response = await fetch(`${supabaseUrl}/rest/v1/`, {\n      method: \"HEAD\",\n      headers: {\n        apikey: supabaseKey,\n        Authorization: `Bearer ${supabaseKey}`,\n      },\n    });\n    const latencyMs = Date.now() - startTime;\n\n    if (response.ok || response.status === 404) {\n      // 404 is OK - means we connected but the table doesn't exist yet\n      return {\n        id: \"enterprise\",\n        name: \"Enterprise Connectivity (Supabase)\",\n        status: \"pass\",\n        message: `Connected to Supabase (${latencyMs}ms)`,\n        details: { status: \"connected\", latencyMs },\n      };\n    } else {\n      return {\n        id: \"enterprise\",\n        name: \"Enterprise Connectivity (Supabase)\",\n        status: \"warning\",\n        message: `Supabase returned ${response.status}`,\n        remediation: \"Check Supabase URL and service key\",\n        details: { status: \"error\", code: response.status },\n      };\n    }\n  } catch (err) {\n    return {\n      id: \"enterprise\",\n      name: \"Enterprise Connectivity (Supabase)\",\n      status: \"warning\",\n      message: `Cannot connect: ${(err as Error).message}`,\n      remediation: \"Check network and Supabase configuration\",\n      details: { status: \"disconnected\" },\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\eval-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\evidence-graph-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\exit-codes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\graph-cli.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'value' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":10,"messageId":"unusedVar","endLine":9,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'entity' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":15,"column":10,"messageId":"unusedVar","endLine":15,"endColumn":16},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":41,"column":43,"messageId":"unexpectedAny","endLine":41,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1111,1114],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1111,1114],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":67,"column":16,"messageId":"unusedVar","endLine":67,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @ts-nocheck\nimport { resolve } from \"node:path\";\n\nasync function loadCore() {\n  const mod = await import(\"@zeo/core\");\n  return mod;\n}\n\nfunction value(argv: string[], flag: string): string | null {\n  const idx = argv.indexOf(flag);\n  return idx >= 0 ? (argv[idx + 1] ?? null) : null;\n}\n\nexport async function runGraphCommand(argv: string[]): Promise<number> {\n  const [entity, action] = argv;\n  const mod = await loadCore();\n  const {\n    buildGraph,\n    detectCycles,\n    calculateFragility,\n    getBlastRadius,\n    envelopeFilesInDir,\n    loadEnvelopeFromFile,\n  } = mod;\n\n  // We scan the current directory for all transcripts to build the graph context\n  const cwd = process.cwd();\n  const files = envelopeFilesInDir(cwd);\n\n  if (files.length === 0) {\n    console.error(\"No transcript envelopes found in current directory.\");\n    return 1;\n  }\n\n  const transcripts = files.map((f) => {\n    const env = loadEnvelopeFromFile(f);\n    return env.transcript;\n  });\n\n  // Cast to FinalizedDecisionTranscript[] as the type from core might differ slightly in strictness\n  const graph = buildGraph(transcripts as any[]);\n\n  // Check for cycles first as they invalidate the graph logic generally\n  const cycles = detectCycles(graph);\n  if (cycles.length > 0) {\n    console.warn(\"WARNING: Cycles detected in decision graph:\");\n    console.warn(JSON.stringify(cycles, null, 2));\n    // We don't exit for 'show' but maybe strictly for 'fragility'?\n    // Requirement: \"DAG only (detect and reject cycles)\".\n    // So if cycles, maybe we should reject.\n    if (action === \"fragility\" || action === \"impact\") {\n      console.error(\"Cannot compute reliable metrics on cyclic graph.\");\n      return 1;\n    }\n  }\n\n  if (action === \"show\") {\n    const targetHash = argv[2];\n    if (!targetHash) throw new Error(\"Usage: zeo graph show <transcript_hash_or_file>\");\n\n    let hash = targetHash;\n    // If it looks like a file path (ends in .json), try to load it to get the hash\n    if (targetHash.endsWith(\".json\")) {\n      try {\n        const env = loadEnvelopeFromFile(resolve(cwd, targetHash));\n        hash = env.transcript_hash;\n      } catch (e) {\n        // ignore, assume it's a hash\n      }\n    }\n\n    const node = graph.nodes.get(hash);\n    if (!node) {\n      console.error(`Transcript with hash or from file '${targetHash}' not found in graph.`);\n      return 1;\n    }\n\n    console.log(\n      JSON.stringify(\n        {\n          id: node.id,\n          dependencies: node.dependencies,\n          dependents: node.dependents,\n          blast_radius: getBlastRadius(graph, node.id).length,\n        },\n        null,\n        2,\n      ),\n    );\n    return 0;\n  }\n\n  if (action === \"impact\") {\n    const targetHash = argv[2];\n    if (!targetHash) throw new Error(\"Usage: zeo graph impact <transcript_hash_or_file>\");\n\n    let hash = targetHash;\n    if (targetHash.endsWith(\".json\")) {\n      try {\n        const env = loadEnvelopeFromFile(resolve(cwd, targetHash));\n        hash = env.transcript_hash;\n      } catch {\n        // If not a valid envelope file, treat input as a transcript hash.\n      }\n    }\n\n    const impacted = getBlastRadius(graph, hash);\n    console.log(\n      JSON.stringify(\n        {\n          transcript_hash: hash,\n          impact_count: impacted.length,\n          impacted_transcripts: impacted,\n        },\n        null,\n        2,\n      ),\n    );\n    return 0;\n  }\n\n  if (action === \"fragility\") {\n    const ranking = calculateFragility(graph);\n    console.log(JSON.stringify(ranking, null, 2));\n    return 0;\n  }\n\n  console.error(`Unknown graph action: ${action}`);\n  return 1;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\llm-cli.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":25,"messageId":"unexpectedAny","endLine":52,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1637,1640],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1637,1640],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":27,"messageId":"unexpectedAny","endLine":53,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1681,1684],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1681,1684],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":25,"messageId":"unexpectedAny","endLine":59,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1800,1803],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1800,1803],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":27,"messageId":"unexpectedAny","endLine":60,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1841,1844],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1841,1844],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":25,"messageId":"unexpectedAny","endLine":66,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1964,1967],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1964,1967],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":27,"messageId":"unexpectedAny","endLine":67,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2007,2010],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2007,2010],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":25,"messageId":"unexpectedAny","endLine":72,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2111,2114],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2111,2114],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":27,"messageId":"unexpectedAny","endLine":73,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2153,2156],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2153,2156],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":29,"messageId":"unexpectedAny","endLine":91,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2749,2752],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2749,2752],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":65,"messageId":"unexpectedAny","endLine":91,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2785,2788],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2785,2788],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-assignment","severity":1,"message":"This assigned value is not used in subsequent statements.","line":113,"column":7,"messageId":"unnecessaryAssignment","endLine":113,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { loadConfig } from \"../core/env.js\";\nimport { ErrorCodes, type ErrorCode } from \"../core/errors.js\";\nimport { existsSync, readFileSync } from \"node:fs\";\nimport { resolve } from \"node:path\";\n\nexport type LlmProviderName = \"openai\" | \"anthropic\" | \"openrouter\" | \"ollama\" | \"custom\";\n\nexport interface LlmConfig {\n  provider: LlmProviderName;\n  apiKey?: string;\n  baseUrl?: string;\n  model: string;\n  temperature: number;\n  seed: number;\n}\n\ninterface DoctorArgs {\n  command: \"doctor\" | null;\n  provider?: LlmProviderName;\n  model?: string;\n  baseUrl?: string;\n  apiKey?: string;\n}\n\nexport function parseLlmArgs(argv: string[]): DoctorArgs {\n  const command = argv[0] === \"doctor\" ? \"doctor\" : null;\n  const args: DoctorArgs = { command };\n  for (let i = 1; i < argv.length; i += 1) {\n    const arg = argv[i];\n    const next = argv[i + 1];\n    if ((arg === \"--provider\" || arg === \"-p\") && next) args.provider = next as LlmProviderName;\n    if (arg === \"--model\" && next) args.model = next;\n    if (arg === \"--base-url\" && next) args.baseUrl = next;\n    if (arg === \"--api-key\" && next) args.apiKey = next;\n  }\n  return args;\n}\n\nfunction readJson(path: string): Record<string, unknown> {\n  if (!existsSync(path)) return {};\n  return JSON.parse(readFileSync(path, \"utf8\")) as Record<string, unknown>;\n}\n\nexport function resolveLlmConfig(args: DoctorArgs): LlmConfig {\n  const root = process.cwd();\n  const projectConfig = readJson(resolve(root, \".zeo/config.json\"));\n  const localConfig = readJson(resolve(root, \".zeo/config.local.json\"));\n  const env = loadConfig();\n\n  const provider =\n    args.provider ??\n    (localConfig.llm as any)?.provider ??\n    (projectConfig.llm as any)?.provider ??\n    env.ZEO_LLM_PROVIDER ??\n    \"openai\";\n\n  const model =\n    args.model ??\n    (localConfig.llm as any)?.model ??\n    (projectConfig.llm as any)?.model ??\n    env.ZEO_LLM_MODEL ??\n    \"gpt-4.1-mini\";\n\n  const baseUrl =\n    args.baseUrl ??\n    (localConfig.llm as any)?.baseUrl ??\n    (projectConfig.llm as any)?.baseUrl ??\n    env.ZEO_LLM_BASE_URL;\n\n  const apiKey =\n    args.apiKey ??\n    (localConfig.llm as any)?.apiKey ??\n    (projectConfig.llm as any)?.apiKey ??\n    env.ZEO_LLM_API_KEY ??\n    env.OPENAI_API_KEY ??\n    env.ANTHROPIC_API_KEY ??\n    env.OPENROUTER_API_KEY;\n\n  const temperature = 0;\n  const seed = Number(env.ZEO_LLM_SEED ?? \"7\");\n\n  const normalized = provider === \"custom\" ? \"ollama\" : provider;\n  if (![\"openai\", \"anthropic\", \"openrouter\", \"ollama\"].includes(normalized)) {\n    throw new Error(`Unsupported provider: ${provider}`);\n  }\n\n  if (![\"ollama\"].includes(normalized) && !apiKey) {\n    throw new Error(`Missing API key for provider ${normalized}. Set via --api-key or env/config.`);\n  }\n\n  if ((projectConfig.llm as any)?.apiKey || (localConfig.llm as any)?.apiKey) {\n    throw new Error(\n      \"API keys in .zeo/config*.json are forbidden. Use environment variables or --api-key at runtime.\",\n    );\n  }\n\n  return {\n    provider: normalized as LlmProviderName,\n    model,\n    baseUrl,\n    apiKey,\n    temperature,\n    seed,\n  };\n}\n\nasync function providerHealth(\n  config: LlmConfig,\n): Promise<{ reachable: boolean; modelAvailable: boolean; details: string }> {\n  const headers: Record<string, string> = {\n    \"content-type\": \"application/json\",\n  };\n  let url = \"\";\n\n  if (config.provider === \"openai\") {\n    url = `${config.baseUrl ?? \"https://api.openai.com/v1\"}/models/${config.model}`;\n    headers.authorization = `Bearer ${config.apiKey}`;\n  } else if (config.provider === \"anthropic\") {\n    url = `${config.baseUrl ?? \"https://api.anthropic.com\"}/v1/models`;\n    headers[\"x-api-key\"] = config.apiKey ?? \"\";\n    headers[\"anthropic-version\"] = \"2023-06-01\";\n  } else if (config.provider === \"openrouter\") {\n    url = `${config.baseUrl ?? \"https://openrouter.ai/api/v1\"}/models`;\n    headers.authorization = `Bearer ${config.apiKey}`;\n  } else {\n    url = `${config.baseUrl ?? \"http://127.0.0.1:11434\"}/api/tags`;\n  }\n\n  const response = await fetch(url, { method: \"GET\", headers });\n  if (!response.ok)\n    return {\n      reachable: false,\n      modelAvailable: false,\n      details: `HTTP ${response.status}`,\n    };\n  const payload = (await response.json()) as Record<string, unknown>;\n  const serialized = JSON.stringify(payload);\n  return {\n    reachable: true,\n    modelAvailable: serialized.includes(config.model),\n    details: \"ok\",\n  };\n}\n\nfunction printHelp(): void {\n  console.log(\n    \"\\nZeo LLM Commands\\n\\nUsage:\\n  zeo llm doctor [--provider <name>] [--model <id>] [--base-url <url>]\\n\",\n  );\n}\n\nexport async function runLlmCommand(args: DoctorArgs): Promise<ErrorCode> {\n  if (!args.command) {\n    printHelp();\n    return ErrorCodes.INVALID_INPUT;\n  }\n\n  const config = resolveLlmConfig(args);\n  const health = await providerHealth(config);\n  if (!health.reachable) {\n    console.error(`[LLM_DOCTOR_FAILED] Provider unreachable: ${health.details}`);\n    return ErrorCodes.LLM_PROVIDER_UNREACHABLE;\n  }\n  if (!health.modelAvailable) {\n    console.error(\n      `[LLM_DOCTOR_FAILED] Model '${config.model}' unavailable for provider '${config.provider}'.`,\n    );\n    return ErrorCodes.LLM_MODEL_UNAVAILABLE;\n  }\n  if (config.temperature !== 0) {\n    console.error(\"[LLM_DOCTOR_FAILED] Non-deterministic temperature; must be 0.\");\n    return ErrorCodes.LLM_NON_DETERMINISTIC;\n  }\n\n  console.log(\n    JSON.stringify(\n      {\n        status: \"ok\",\n        provider: config.provider,\n        model: config.model,\n        deterministic: { temperature: config.temperature, seed: config.seed },\n      },\n      null,\n      2,\n    ),\n  );\n  return ErrorCodes.SUCCESS;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\marketplace-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\mcp-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\mesh-cli.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'randomUUID' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":10,"messageId":"unusedVar","endLine":15,"endColumn":20,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"randomUUID"},"fix":{"range":[557,599],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'createJobEnvelope' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":93,"column":11,"messageId":"unusedVar","endLine":93,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":205,"column":40,"messageId":"unexpectedAny","endLine":205,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6678,6681],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6678,6681],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":233,"column":42,"messageId":"unexpectedAny","endLine":233,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7692,7695],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7692,7695],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":275,"column":58,"messageId":"unexpectedAny","endLine":275,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8978,8981],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8978,8981],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":277,"column":25,"messageId":"unexpectedAny","endLine":277,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9035,9038],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9035,9038],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":280,"column":43,"messageId":"unexpectedAny","endLine":280,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9140,9143],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9140,9143],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":292,"column":23,"messageId":"unexpectedAny","endLine":292,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9451,9454],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9451,9454],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @ts-nocheck\n/**\n * Mesh CLI — zeo mesh commands + zeo sign-envelope + zeo verify-envelope\n *\n * Commands:\n *   zeo mesh status                         Show mesh status\n *   zeo mesh batch --mode=local|remote|off  Run batch through mesh\n *   zeo mesh start-worker --port=N          Start a worker server\n *   zeo sign-envelope <file>                Sign a job envelope file\n *   zeo verify-envelope <file>              Verify a job envelope file\n */\n\nimport { readFileSync, writeFileSync, existsSync } from \"node:fs\";\nimport { resolve } from \"node:path\";\nimport { randomUUID } from \"node:crypto\";\nimport { performance } from \"node:perf_hooks\";\n\nexport interface MeshCliArgs {\n  command: string;\n  subcommand?: string;\n  file?: string;\n  port?: number;\n  mode?: string;\n  count?: number;\n  concurrency?: number;\n  json?: boolean;\n  out?: string;\n}\n\nexport function parseMeshArgs(argv: string[]): MeshCliArgs {\n  const args: MeshCliArgs = { command: argv[0] ?? \"status\" };\n\n  if (argv[0] === \"sign-envelope\" || argv[0] === \"verify-envelope\") {\n    args.command = argv[0];\n    args.file = argv[1];\n    args.json = argv.includes(\"--json\");\n    return args;\n  }\n\n  args.subcommand = argv[1];\n\n  for (let i = 0; i < argv.length; i++) {\n    if (argv[i] === \"--port\" && argv[i + 1]) args.port = Number(argv[i + 1]);\n    if (argv[i]?.startsWith(\"--port=\")) args.port = Number(argv[i].split(\"=\")[1]);\n    if (argv[i] === \"--mode\" && argv[i + 1]) args.mode = argv[i + 1];\n    if (argv[i]?.startsWith(\"--mode=\")) args.mode = argv[i].split(\"=\")[1];\n    if (argv[i] === \"--count\" && argv[i + 1]) args.count = Number(argv[i + 1]);\n    if (argv[i]?.startsWith(\"--count=\")) args.count = Number(argv[i].split(\"=\")[1]);\n    if (argv[i] === \"--concurrency\" && argv[i + 1]) args.concurrency = Number(argv[i + 1]);\n    if (argv[i]?.startsWith(\"--concurrency=\")) args.concurrency = Number(argv[i].split(\"=\")[1]);\n    if (argv[i] === \"--json\") args.json = true;\n    if (argv[i] === \"--out\" && argv[i + 1]) args.out = argv[i + 1];\n    if (argv[i]?.startsWith(\"--out=\")) args.out = argv[i].split(\"=\")[1];\n    if (i >= 2 && !argv[i].startsWith(\"--\")) args.file = args.file ?? argv[i];\n  }\n\n  return args;\n}\n\nexport async function runMeshCommand(args: MeshCliArgs): Promise<number> {\n  try {\n    switch (args.command) {\n      case \"sign-envelope\":\n        return await cmdSignEnvelope(args);\n      case \"verify-envelope\":\n        return await cmdVerifyEnvelope(args);\n      case \"mesh\":\n        return await cmdMesh(args);\n      default:\n        console.error(`Unknown mesh command: ${args.command}`);\n        return 1;\n    }\n  } catch (err) {\n    console.error(`Error: ${err instanceof Error ? err.message : String(err)}`);\n    return 1;\n  }\n}\n\n// ─── sign-envelope ───────────────────────────────────────────────────────\n\nasync function cmdSignEnvelope(args: MeshCliArgs): Promise<number> {\n  if (!args.file) {\n    console.error(\"Usage: zeo sign-envelope <file> [--out <path>]\");\n    return 1;\n  }\n\n  const filePath = resolve(args.file);\n  if (!existsSync(filePath)) {\n    console.error(`File not found: ${filePath}`);\n    return 1;\n  }\n\n  const { createJobEnvelope, computeCanonicalHash } = await import(\"@zeo/mesh\");\n\n  const raw = JSON.parse(readFileSync(filePath, \"utf8\"));\n\n  // If it already has a signature, re-sign\n  const unsigned = { ...raw, signature: \"\" };\n  const body = {\n    envelope_version: unsigned.envelope_version,\n    job_id: unsigned.job_id,\n    tenant_id: unsigned.tenant_id,\n    policy_snapshot: unsigned.policy_snapshot,\n    kernel_input: unsigned.kernel_input,\n    schema_versions: unsigned.schema_versions,\n    deterministic_config: unsigned.deterministic_config,\n    trace_id: unsigned.trace_id,\n    created_at: unsigned.created_at,\n    nonce: unsigned.nonce,\n  };\n\n  const signature = computeCanonicalHash(body);\n  const signed = { ...unsigned, signature };\n\n  const outPath = args.out ? resolve(args.out) : filePath;\n  writeFileSync(outPath, JSON.stringify(signed, null, 2) + \"\\n\", \"utf8\");\n\n  if (args.json) {\n    console.log(JSON.stringify({ ok: true, signature, path: outPath }));\n  } else {\n    console.log(`✓ Envelope signed`);\n    console.log(`  Signature: ${signature.slice(0, 16)}...`);\n    console.log(`  Written to: ${outPath}`);\n  }\n\n  return 0;\n}\n\n// ─── verify-envelope ─────────────────────────────────────────────────────\n\nasync function cmdVerifyEnvelope(args: MeshCliArgs): Promise<number> {\n  if (!args.file) {\n    console.error(\"Usage: zeo verify-envelope <file>\");\n    return 1;\n  }\n\n  const filePath = resolve(args.file);\n  if (!existsSync(filePath)) {\n    console.error(`File not found: ${filePath}`);\n    return 1;\n  }\n\n  const { verifyJobEnvelope, verifyResultEnvelope } = await import(\"@zeo/mesh\");\n\n  const raw = JSON.parse(readFileSync(filePath, \"utf8\"));\n\n  // Detect if it's a job envelope or result envelope\n  if (raw.envelope_version) {\n    const result = verifyJobEnvelope(raw);\n    if (args.json) {\n      console.log(JSON.stringify(result));\n    } else if (result.valid) {\n      console.log(\"✓ Job envelope signature VALID\");\n      console.log(`  Job ID:    ${raw.job_id}`);\n      console.log(`  Tenant:    ${raw.tenant_id}`);\n      console.log(`  Signature: ${raw.signature?.slice(0, 16)}...`);\n    } else {\n      console.error(\"✗ Job envelope signature INVALID\");\n      for (const err of result.errors) {\n        console.error(`  Error: ${err}`);\n      }\n      return 1;\n    }\n  } else if (raw.result_version) {\n    const result = verifyResultEnvelope(raw);\n    if (args.json) {\n      console.log(JSON.stringify(result));\n    } else if (result.valid) {\n      console.log(\"✓ Result envelope signature VALID\");\n      console.log(`  Job ID:      ${raw.job_id}`);\n      console.log(`  Output Hash: ${raw.output_hash?.slice(0, 16)}...`);\n    } else {\n      console.error(\"✗ Result envelope signature INVALID\");\n      for (const err of result.errors) {\n        console.error(`  Error: ${err}`);\n      }\n      return 1;\n    }\n  } else {\n    console.error(\"Unknown envelope type. Expected envelope_version or result_version field.\");\n    return 1;\n  }\n\n  return 0;\n}\n\n// ─── mesh subcommands ────────────────────────────────────────────────────\n\nasync function cmdMesh(args: MeshCliArgs): Promise<number> {\n  switch (args.subcommand) {\n    case \"status\":\n      return await cmdMeshStatus(args);\n    case \"batch\":\n      return await cmdMeshBatch(args);\n    case \"start-worker\":\n      return await cmdMeshStartWorker(args);\n    default:\n      printMeshHelp();\n      return 0;\n  }\n}\n\nasync function cmdMeshStatus(args: MeshCliArgs): Promise<number> {\n  const { MeshOrchestrator } = await import(\"@zeo/mesh\");\n  const mode = (args.mode ?? \"off\") as any;\n  const orch = new MeshOrchestrator({ mode });\n  const status = orch.getMeshStatus();\n\n  if (args.json) {\n    console.log(JSON.stringify(status, null, 2));\n  } else {\n    console.log(\"=== Mesh Status ===\");\n    console.log(`Mode:            ${status.mode}`);\n    console.log(`Total Workers:   ${status.totalWorkers}`);\n    console.log(`Healthy Workers: ${status.healthyWorkers}`);\n    console.log(`Completed Jobs:  ${status.completedJobs}`);\n    if (status.workers.length > 0) {\n      console.log(\"\\nWorkers:\");\n      for (const w of status.workers) {\n        const state = w.circuitOpen ? \"CIRCUIT_OPEN\" : w.healthy ? \"healthy\" : \"unhealthy\";\n        console.log(`  ${w.id}: ${w.url} [${state}] jobs=${w.totalJobsHandled}`);\n      }\n    }\n  }\n\n  return 0;\n}\n\nasync function cmdMeshBatch(args: MeshCliArgs): Promise<number> {\n  const { MeshOrchestrator, ENVELOPE_VERSION } = await import(\"@zeo/mesh\");\n  const { KERNEL_SCHEMA_VERSION } = await import(\"@zeo/kernel\");\n\n  const mode = (args.mode ?? \"local\") as any;\n  const count = args.count ?? 5;\n  const concurrency = args.concurrency ?? 4;\n\n  console.log(`Running ${count} jobs in ${mode} mode (concurrency: ${concurrency})...`);\n\n  const orch = new MeshOrchestrator({\n    mode,\n    maxConcurrency: concurrency,\n  });\n\n  const jobs = Array.from({ length: count }, (_, i) => ({\n    kernel_input: {\n      spec: {\n        id: `spec_batch_${i}`,\n        title: `Batch Decision ${i}`,\n        context: \"Mesh batch test\",\n        horizon: \"days\" as const,\n        agents: [{ id: \"agent_1\", label: \"Agent\", perspective: \"Analytical\" }],\n        actions: [\n          { id: \"act_1\", label: \"Accept\", actorId: \"agent_1\", kind: \"accept\" },\n          { id: \"act_2\", label: \"Reject\", actorId: \"agent_1\", kind: \"reject\" },\n        ],\n        constraints: [\n          {\n            id: \"c1\",\n            name: \"Budget\",\n            value: \"$5000\",\n            status: \"fact\" as const,\n            provenance: [\"system\"],\n          },\n        ],\n        assumptions: [\n          {\n            id: \"a1\",\n            text: \"Stable\",\n            status: \"assumption\" as const,\n            confidence: \"medium\" as const,\n          },\n        ],\n        objectives: [{ metric: \"ROI\", weight: 1 }],\n      },\n      evidenceSnapshot: { version: \"1.0.0\", nodes: [] as any[] },\n      policySnapshot: {\n        policies: [] as any[],\n        enforcementStrength: \"basic\" as const,\n      },\n      toolResultsSnapshot: { tools: [] as any[] },\n      config: {\n        seed: `batch-${i}`,\n        floatPrecision: 10,\n        maxDepth: 2 as const,\n        maxBranchesPerAction: 4,\n        useQuantEngine: false,\n      },\n      schemaVersion: KERNEL_SCHEMA_VERSION,\n    },\n    tenant_id: \"tenant_batch\",\n    policy_snapshot: {\n      policies: [] as any[],\n      enforcementStrength: \"basic\" as const,\n    },\n  }));\n\n  const start = performance.now();\n  const result = await orch.executeBatch(\n    jobs,\n    {\n      seed: \"batch-test\",\n      float_precision: 10,\n      max_depth: 2,\n    },\n    {\n      envelope: ENVELOPE_VERSION,\n      kernel: KERNEL_SCHEMA_VERSION,\n      ir: \"1.0.0\",\n      policy: \"1.0.0\",\n    },\n  );\n  const duration = performance.now() - start;\n\n  if (args.json) {\n    console.log(\n      JSON.stringify(\n        {\n          stats: result.stats,\n          duration_ms: Math.round(duration),\n          throughput: (count / (duration / 1000)).toFixed(1),\n        },\n        null,\n        2,\n      ),\n    );\n  } else {\n    console.log(`\\n=== Batch Results ===`);\n    console.log(`Jobs:          ${result.stats.total_jobs}`);\n    console.log(`Succeeded:     ${result.stats.succeeded}`);\n    console.log(`Failed:        ${result.stats.failed}`);\n    console.log(`Retried:       ${result.stats.retried}`);\n    console.log(`Fallbacks:     ${result.stats.fallback_local}`);\n    console.log(`Duration:      ${duration.toFixed(2)}ms`);\n    console.log(`Throughput:    ${(count / (duration / 1000)).toFixed(1)} jobs/sec`);\n    console.log(`Avg per job:   ${(duration / count).toFixed(2)}ms`);\n    console.log(`Memory:        ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(1)}MB`);\n  }\n\n  return result.stats.failed > 0 ? 1 : 0;\n}\n\nasync function cmdMeshStartWorker(args: MeshCliArgs): Promise<number> {\n  const { startWorkerServer } = await import(\"@zeo/mesh\");\n\n  const port = args.port ?? 9876;\n  console.log(`Starting mesh worker on port ${port}...`);\n\n  const worker = await startWorkerServer({ port });\n  console.log(`Worker ${worker.workerId} listening on port ${port}`);\n  console.log(`  POST /execute — Submit job envelope`);\n  console.log(`  GET  /health  — Health check`);\n  console.log(`\\nPress Ctrl+C to stop.`);\n\n  // Keep running until interrupted\n  await new Promise(() => {}); // blocks forever\n  return 0;\n}\n\nfunction printMeshHelp(): void {\n  console.log(`\nZeo Mesh — Federated Worker Mesh Commands\n\nUsage:\n  zeo mesh status                         Show mesh status\n  zeo mesh batch [--mode=local] [--count=N] [--concurrency=N]\n                                          Run batch through mesh\n  zeo mesh start-worker [--port=N]        Start a worker server\n\n  zeo sign-envelope <file> [--out <path>] Sign a job envelope\n  zeo verify-envelope <file>              Verify a job/result envelope\n\nOptions:\n  --mode=off|local|remote    Mesh execution mode (default: local)\n  --count=N                  Number of jobs in batch (default: 5)\n  --concurrency=N            Max concurrent jobs (default: 4)\n  --port=N                   Worker server port (default: 9876)\n  --json                     JSON output\n  --out <path>               Output file path\n`);\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\pack-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\perf-cli.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'scanHotPaths' is defined but never used. Allowed unused vars must match /^_/u.","line":20,"column":3,"messageId":"unusedVar","endLine":20,"endColumn":15,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"scanHotPaths"},"fix":{"range":[763,779],"text":""},"desc":"Remove unused variable \"scanHotPaths\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'HotPathFinding' is defined but never used. Allowed unused vars must match /^_/u.","line":24,"column":8,"messageId":"unusedVar","endLine":24,"endColumn":22,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"HotPathFinding"},"fix":{"range":[842,865],"text":""},"desc":"Remove unused variable \"HotPathFinding\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Profiler' is defined but never used. Allowed unused vars must match /^_/u.","line":25,"column":3,"messageId":"unusedVar","endLine":25,"endColumn":11,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"Profiler"},"fix":{"range":[865,877],"text":""},"desc":"Remove unused variable \"Profiler\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'startQuickProfile' is defined but never used. Allowed unused vars must match /^_/u.","line":27,"column":3,"messageId":"unusedVar","endLine":27,"endColumn":20,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"startQuickProfile"},"fix":{"range":[898,919],"text":""},"desc":"Remove unused variable \"startQuickProfile\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'endQuickProfile' is defined but never used. Allowed unused vars must match /^_/u.","line":28,"column":3,"messageId":"unusedVar","endLine":28,"endColumn":18,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"endQuickProfile"},"fix":{"range":[919,938],"text":""},"desc":"Remove unused variable \"endQuickProfile\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ProfilerOptions' is defined but never used. Allowed unused vars must match /^_/u.","line":30,"column":8,"messageId":"unusedVar","endLine":30,"endColumn":23,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"ProfilerOptions"},"fix":{"range":[960,984],"text":""},"desc":"Remove unused variable \"ProfilerOptions\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ReplayOptions' is defined but never used. Allowed unused vars must match /^_/u.","line":44,"column":45,"messageId":"unusedVar","endLine":44,"endColumn":58,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"ReplayOptions"},"fix":{"range":[1474,1494],"text":""},"desc":"Remove unused variable \"ReplayOptions\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":280,"column":16,"messageId":"unusedVar","endLine":280,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'seed' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":471,"column":13,"messageId":"unusedVar","endLine":471,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'seed' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":485,"column":11,"messageId":"unusedVar","endLine":485,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":688,"column":16,"messageId":"unusedVar","endLine":688,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @ts-nocheck\nimport { loadConfig } from \"../core/env.js\";\n/**\n * Performance CLI Module\n *\n * Commands:\n *   zeo perf scan [--severity critical] [--paths packages/core,packages/replay]\n *   zeo perf profile --example negotiation --depth 3 [--out perf-report.json]\n *   zeo perf benchmark [--baseline baseline.json] [--out results.json]\n *   zeo perf compare --baseline baseline.json --current current.json\n *   zeo perf regression --replay dataset.json [--threshold 10%]\n */\n\nimport { readFileSync, writeFileSync, existsSync, readdirSync, statSync } from \"node:fs\";\nimport { resolve, join, relative } from \"node:path\";\nimport { cwd } from \"node:process\";\n// @ts-ignore - External packages may not be available in all environments\nimport {\n  StaticHotPathScanner,\n  scanHotPaths,\n  type ScanOptions,\n  type HotPathSeverity,\n  type ScanResult,\n  type HotPathFinding,\n  Profiler,\n  getGlobalProfiler,\n  startQuickProfile,\n  endQuickProfile,\n  type ProfileReport,\n  type ProfilerOptions,\n} from \"@zeo/perf\";\n// @ts-ignore - External packages may not be available in all environments\nimport {\n  makeNegotiationExample,\n  makeOpsExample,\n  runDecision,\n  computeDeterministicSeed,\n  hashDecisionSpec,\n  canonicalizeDecisionSpec,\n} from \"@zeo/core\";\n// @ts-ignore - External packages may not be available in all environments\nimport { replayCase } from \"@zeo/replay\";\n// @ts-ignore - External packages may not be available in all environments\nimport { ZeoError, type ReplayDataset, type ReplayOptions } from \"@zeo/contracts\";\n\nexport interface PerfCliArgs {\n  command: \"scan\" | \"profile\" | \"benchmark\" | \"compare\" | \"regression\" | null;\n  // Scan options\n  paths: string[];\n  severity: HotPathSeverity;\n  maxFindings: number;\n  experimental: boolean;\n  // Profile options\n  example: \"negotiation\" | \"ops\";\n  depth: 2 | 3;\n  seed?: string;\n  // Output options\n  out?: string;\n  jsonOnly: boolean;\n  // Compare options\n  baseline?: string;\n  current?: string;\n  // Regression options\n  replay?: string;\n  threshold: number; // percentage\n  // Benchmark options\n  iterations: number;\n  warmup: number;\n}\n\nexport function parsePerfArgs(argv: string[]): PerfCliArgs {\n  const result: PerfCliArgs = {\n    command: null,\n    paths: [],\n    severity: \"low\",\n    maxFindings: 100,\n    experimental: false,\n    example: \"negotiation\",\n    depth: 2,\n    jsonOnly: false,\n    threshold: 10, // 10% regression threshold\n    iterations: 5,\n    warmup: 2,\n  };\n\n  // First argument after \"perf\" is the command\n  const perfIdx = argv.indexOf(\"perf\");\n  if (perfIdx !== -1 && argv[perfIdx + 1]) {\n    const cmd = argv[perfIdx + 1];\n    if ([\"scan\", \"profile\", \"benchmark\", \"compare\", \"regression\"].includes(cmd)) {\n      result.command = cmd as PerfCliArgs[\"command\"];\n    }\n  }\n\n  // Also check if first arg is a command (when called directly)\n  if (\n    !result.command &&\n    argv[0] &&\n    [\"scan\", \"profile\", \"benchmark\", \"compare\", \"regression\"].includes(argv[0])\n  ) {\n    result.command = argv[0] as PerfCliArgs[\"command\"];\n  }\n\n  for (let i = 0; i < argv.length; i++) {\n    const arg = argv[i];\n    const next = argv[i + 1];\n\n    if (arg === \"--paths\" && next) {\n      result.paths = next.split(\",\").map((p) => p.trim());\n      i++;\n    } else if (arg === \"--severity\" && next) {\n      if ([\"low\", \"medium\", \"high\", \"critical\"].includes(next)) {\n        result.severity = next as HotPathSeverity;\n      }\n      i++;\n    } else if (arg === \"--max-findings\" && next) {\n      result.maxFindings = parseInt(next, 10);\n      i++;\n    } else if (arg === \"--experimental\") {\n      result.experimental = true;\n    } else if (arg === \"--example\" && next) {\n      if (next === \"negotiation\" || next === \"ops\") {\n        result.example = next;\n      }\n      i++;\n    } else if (arg === \"--depth\" && next) {\n      const d = parseInt(next, 10);\n      if (d === 2 || d === 3) result.depth = d as 2 | 3;\n      i++;\n    } else if (arg === \"--seed\" && next) {\n      result.seed = next;\n      i++;\n    } else if (arg === \"--out\" && next) {\n      result.out = next;\n      i++;\n    } else if (arg === \"--json-only\") {\n      result.jsonOnly = true;\n    } else if (arg === \"--baseline\" && next) {\n      result.baseline = next;\n      i++;\n    } else if (arg === \"--current\" && next) {\n      result.current = next;\n      i++;\n    } else if (arg === \"--replay\" && next) {\n      result.replay = next;\n      i++;\n    } else if (arg === \"--threshold\" && next) {\n      result.threshold = parseFloat(next);\n      i++;\n    } else if (arg === \"--iterations\" && next) {\n      result.iterations = parseInt(next, 10);\n      i++;\n    } else if (arg === \"--warmup\" && next) {\n      result.warmup = parseInt(next, 10);\n      i++;\n    } else if (arg === \"--help\" || arg === \"-h\") {\n      printPerfHelp();\n      process.exit(0);\n    }\n  }\n\n  return result;\n}\n\nfunction printPerfHelp(): void {\n  console.log(`\nZeo Performance CLI - Profiling and benchmarking tools\n\nUsage: zeo perf <command> [options]\n\nCommands:\n  scan                        Scan for performance hot paths in source code\n  profile                     Profile a decision run\n  benchmark                   Run performance benchmarks\n  compare                     Compare two performance reports\n  regression                  Run performance regression tests using replay\n\nScan Options:\n  --paths <dirs>              Comma-separated paths to scan (default: packages/)\n  --severity <level>          Minimum severity: low|medium|high|critical (default: low)\n  --max-findings <n>          Maximum findings to report (default: 100)\n  --experimental              Enable experimental patterns\n\nProfile Options:\n  --example <name>            Example to profile: negotiation|ops (default: negotiation)\n  --depth <n>                 Branching depth: 1-5 (default: 2)\n  --seed <string>             Random seed for deterministic runs\n\nBenchmark Options:\n  --iterations <n>            Number of iterations (default: 5)\n  --warmup <n>                Warmup iterations (default: 2)\n  --example <name>            Example to benchmark (default: negotiation)\n  --depth <n>                 Branching depth (default: 3)\n\nCompare Options:\n  --baseline <file>           Baseline performance report JSON\n  --current <file>            Current performance report JSON\n\nRegression Options:\n  --replay <file>             Replay dataset to use for regression testing\n  --threshold <pct>           Regression threshold percentage (default: 10)\n\nOutput Options:\n  --out <path>                Write JSON output to file\n  --json-only                 Output JSON only, no summary\n\nExamples:\n  zeo perf scan --paths packages/core --severity critical\n  zeo perf profile --example negotiation --depth 3 --out perf.json\n  zeo perf benchmark --iterations 10 --out benchmark.json\n  zeo perf compare --baseline baseline.json --current current.json\n  zeo perf regression --replay external/examples/replay/sample_dataset.json\n`);\n}\n\n/**\n * Recursively get all TypeScript files in a directory\n */\nfunction getTypeScriptFiles(dir: string, files: string[] = []): string[] {\n  const items = readdirSync(dir);\n\n  for (const item of items) {\n    const fullPath = join(dir, item);\n    const stat = statSync(fullPath);\n\n    if (stat.isDirectory()) {\n      // Skip node_modules and dist\n      if (item === \"node_modules\" || item === \"dist\" || item === \".git\") {\n        continue;\n      }\n      getTypeScriptFiles(fullPath, files);\n    } else if (stat.isFile() && (item.endsWith(\".ts\") || item.endsWith(\".tsx\"))) {\n      // Skip test files and declaration files\n      if (!item.endsWith(\".test.ts\") && !item.endsWith(\".d.ts\")) {\n        files.push(fullPath);\n      }\n    }\n  }\n\n  return files;\n}\n\n/**\n * Run hot path scan\n */\nasync function runScanCommand(args: PerfCliArgs): Promise<number> {\n  console.log(\"\\n=== Zeo Performance Scan ===\");\n\n  const paths = args.paths.length > 0 ? args.paths : [\"packages\"];\n  const fullPaths = paths.map((p) => resolve(cwd(), p));\n\n  console.log(`Scanning paths: ${paths.join(\", \")}`);\n  console.log(`Severity threshold: ${args.severity}`);\n  console.log(`Experimental patterns: ${args.experimental ? \"enabled\" : \"disabled\"}`);\n  console.log(\"\");\n\n  const scanOptions: ScanOptions = {\n    severityThreshold: args.severity,\n    maxFindings: args.maxFindings,\n    enableExperimentalPatterns: args.experimental,\n  };\n\n  const scanner = new StaticHotPathScanner(scanOptions);\n  const allFiles: Array<{ path: string; content: string }> = [];\n\n  // Collect all files\n  for (const basePath of fullPaths) {\n    if (!existsSync(basePath)) {\n      console.warn(`Warning: Path does not exist: ${basePath}`);\n      continue;\n    }\n\n    const files = getTypeScriptFiles(basePath);\n    console.log(`Found ${files.length} TypeScript files in ${relative(cwd(), basePath)}`);\n\n    for (const file of files) {\n      try {\n        const content = readFileSync(file, \"utf8\");\n        allFiles.push({ path: relative(cwd(), file), content });\n      } catch (err) {\n        console.warn(`Warning: Could not read ${file}`);\n      }\n    }\n  }\n\n  console.log(`\\nScanning ${allFiles.length} files...\\n`);\n\n  const result = scanner.scanFiles(allFiles);\n\n  // Print results\n  printScanResults(result);\n\n  // Write output if requested\n  if (args.out) {\n    writeFileSync(args.out, JSON.stringify(result, null, 2), \"utf8\");\n    console.log(`\\nScan results written to: ${args.out}`);\n  }\n\n  // Return exit code based on critical findings\n  if (result.summary.findingsBySeverity.critical > 0) {\n    console.log(\"\\n⚠️  Critical hot paths detected!\");\n    return 1;\n  }\n\n  return 0;\n}\n\nfunction printScanResults(result: ScanResult): void {\n  console.log(\n    `Scanned ${result.summary.totalFilesScanned} files (${result.summary.totalLinesScanned} lines)`,\n  );\n  console.log(`Found ${result.findings.length} hot paths in ${result.durationMs}ms\\n`);\n\n  if (result.findings.length === 0) {\n    console.log(\"✓ No performance issues detected.\");\n    return;\n  }\n\n  // Summary by severity\n  console.log(\"Findings by severity:\");\n  for (const [severity, count] of Object.entries(result.summary.findingsBySeverity)) {\n    const countNum = count as number;\n    if (countNum > 0) {\n      const icon =\n        severity === \"critical\"\n          ? \"🔴\"\n          : severity === \"high\"\n            ? \"🟠\"\n            : severity === \"medium\"\n              ? \"🟡\"\n              : \"⚪\";\n      console.log(`  ${icon} ${severity}: ${countNum}`);\n    }\n  }\n\n  // Summary by category\n  console.log(\"\\nFindings by category:\");\n  for (const [category, count] of Object.entries(result.summary.findingsByCategory)) {\n    const countNum = count as number;\n    if (countNum > 0) {\n      console.log(`  ${category}: ${countNum}`);\n    }\n  }\n\n  // Critical paths\n  if (result.summary.criticalPaths.length > 0) {\n    console.log(\"\\n🔴 Critical Paths (require immediate attention):\");\n    for (const finding of result.summary.criticalPaths.slice(0, 10)) {\n      console.log(`\\n  ${finding.filePath}:${finding.lineNumber}`);\n      console.log(`    ${finding.description}`);\n      console.log(`    ${finding.recommendation}`);\n    }\n  }\n\n  // Top findings by complexity\n  console.log(\"\\n📊 Top 10 Findings by Complexity Score:\");\n  const topFindings = result.findings.slice(0, 10);\n  for (let i = 0; i < topFindings.length; i++) {\n    const f = topFindings[i];\n    const icon =\n      f.severity === \"critical\"\n        ? \"🔴\"\n        : f.severity === \"high\"\n          ? \"🟠\"\n          : f.severity === \"medium\"\n            ? \"🟡\"\n            : \"⚪\";\n    console.log(`\\n  ${i + 1}. ${icon} ${f.filePath}:${f.lineNumber}`);\n    console.log(`     Function: ${f.functionName}`);\n    console.log(`     Category: ${f.category} | Score: ${f.complexityScore}/100`);\n    console.log(`     ${f.description}`);\n  }\n}\n\n/**\n * Run profiling on a decision\n */\nasync function runProfileCommand(args: PerfCliArgs): Promise<number> {\n  console.log(\"\\n=== Zeo Performance Profile ===\");\n\n  const spec = args.example === \"ops\" ? makeOpsExample() : makeNegotiationExample();\n  const canonicalSpec = canonicalizeDecisionSpec(spec);\n  const decisionHash = hashDecisionSpec(canonicalSpec);\n  const seed = args.seed || computeDeterministicSeed(decisionHash, undefined, args.depth);\n\n  console.log(`Example: ${args.example}`);\n  console.log(`Depth: ${args.depth}`);\n  console.log(`Seed: ${seed.slice(0, 16)}...\\n`);\n\n  // Create profiler\n  const profiler = getGlobalProfiler({ trackMemory: true });\n  const session = profiler.startSession(`profile-${args.example}-d${args.depth}`);\n  const sessionId = session.id;\n\n  // Profile the decision run\n  await profiler.profile(\n    \"decision-run\",\n    sessionId,\n    async () => {\n      return runDecision(spec, { depth: args.depth });\n    },\n    { functionName: \"runDecision\", filePath: \"@zeo/core\" },\n  );\n\n  profiler.endSession(sessionId);\n  const report = profiler.generateReport(sessionId);\n\n  // Print results\n  printProfileReport(report);\n\n  // Write output if requested\n  if (args.out) {\n    const output = {\n      report,\n      metadata: {\n        example: args.example,\n        depth: args.depth,\n        seed,\n        decisionHash,\n      },\n    };\n    writeFileSync(args.out, JSON.stringify(output, null, 2), \"utf8\");\n    console.log(`\\nProfile report written to: ${args.out}`);\n  }\n\n  return 0;\n}\n\nfunction printProfileReport(report: ProfileReport): void {\n  console.log(`\\nSession: ${report.session.name}`);\n  console.log(`Duration: ${report.summary.totalDuration}ms`);\n  console.log(`Measurements: ${report.summary.totalMeasurements}`);\n  console.log(`Average: ${report.summary.averageDuration.toFixed(2)}ms`);\n\n  if (report.summary.memoryGrowth > 0) {\n    console.log(`Memory Growth: ${(report.summary.memoryGrowth / 1024 / 1024).toFixed(2)}MB`);\n  }\n\n  if (report.summary.longestOperations.length > 0) {\n    console.log(\"\\nLongest Operations:\");\n    for (const op of report.summary.longestOperations.slice(0, 5)) {\n      console.log(`  ${op.name}: ${op.duration?.toFixed(2)}ms`);\n    }\n  }\n\n  console.log(\"\\n📋 Recommendations:\");\n  for (const rec of report.recommendations) {\n    console.log(`  • ${rec}`);\n  }\n}\n\n/**\n * Run performance benchmark\n */\nasync function runBenchmarkCommand(args: PerfCliArgs): Promise<number> {\n  console.log(\"\\n=== Zeo Performance Benchmark ===\");\n\n  const spec = args.example === \"ops\" ? makeOpsExample() : makeNegotiationExample();\n  const canonicalSpec = canonicalizeDecisionSpec(spec);\n  const decisionHash = hashDecisionSpec(canonicalSpec);\n\n  console.log(`Example: ${args.example}`);\n  console.log(`Depth: ${args.depth}`);\n  console.log(`Warmup: ${args.warmup} iterations`);\n  console.log(`Iterations: ${args.iterations}\\n`);\n\n  // Warmup\n  if (args.warmup > 0) {\n    console.log(\"Running warmup...\");\n    for (let i = 0; i < args.warmup; i++) {\n      const seed = computeDeterministicSeed(decisionHash, undefined, args.depth);\n      runDecision(spec, { depth: args.depth });\n    }\n  }\n\n  // Benchmark\n  console.log(\"Running benchmark...\\n\");\n  const measurements: number[] = [];\n  const memorySnapshots: number[] = [];\n\n  for (let i = 0; i < args.iterations; i++) {\n    const memBefore = process.memoryUsage().heapUsed;\n    const start = performance.now();\n\n    const seed = computeDeterministicSeed(decisionHash, undefined, args.depth);\n    runDecision(spec, { depth: args.depth });\n\n    const duration = performance.now() - start;\n    const memAfter = process.memoryUsage().heapUsed;\n\n    measurements.push(duration);\n    memorySnapshots.push(memAfter - memBefore);\n\n    process.stdout.write(`  Iteration ${i + 1}/${args.iterations}: ${duration.toFixed(2)}ms\\r`);\n  }\n  console.log(\"\"); // New line after progress\n\n  // Calculate statistics\n  const stats = calculateStats(measurements);\n  const memStats = calculateStats(memorySnapshots);\n\n  const benchmark: BenchmarkResult = {\n    metadata: {\n      example: args.example,\n      depth: args.depth,\n      iterations: args.iterations,\n      warmup: args.warmup,\n      timestamp: new Date().toISOString(),\n    },\n    timing: stats,\n    memory: {\n      mean: memStats.mean,\n      stdDev: memStats.stdDev,\n      min: memStats.min,\n      max: memStats.max,\n      unit: \"bytes\",\n    },\n    rawMeasurements: measurements,\n  };\n\n  // Print results\n  printBenchmarkResults(benchmark);\n\n  // Write output if requested\n  if (args.out) {\n    writeFileSync(args.out, JSON.stringify(benchmark, null, 2), \"utf8\");\n    console.log(`\\nBenchmark results written to: ${args.out}`);\n  }\n\n  return 0;\n}\n\ninterface BenchmarkResult {\n  metadata: {\n    example: string;\n    depth: number;\n    iterations: number;\n    warmup: number;\n    timestamp: string;\n  };\n  timing: {\n    mean: number;\n    median: number;\n    stdDev: number;\n    min: number;\n    max: number;\n    p95: number;\n    p99: number;\n  };\n  memory: {\n    mean: number;\n    stdDev: number;\n    min: number;\n    max: number;\n    unit: string;\n  };\n  rawMeasurements: number[];\n}\n\nfunction calculateStats(values: number[]) {\n  const sorted = [...values].sort((a, b) => a - b);\n  const mean = values.reduce((a, b) => a + b, 0) / values.length;\n  const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;\n  const stdDev = Math.sqrt(variance);\n\n  return {\n    mean,\n    median: sorted[Math.floor(sorted.length / 2)],\n    stdDev,\n    min: sorted[0],\n    max: sorted[sorted.length - 1],\n    p95: sorted[Math.floor(sorted.length * 0.95)],\n    p99: sorted[Math.floor(sorted.length * 0.99)],\n  };\n}\n\nfunction printBenchmarkResults(result: BenchmarkResult): void {\n  console.log(\"\\n📊 Benchmark Results\\n\");\n\n  console.log(\"Timing Statistics:\");\n  console.log(`  Mean:   ${result.timing.mean.toFixed(2)}ms`);\n  console.log(`  Median: ${result.timing.median.toFixed(2)}ms`);\n  console.log(`  StdDev: ${result.timing.stdDev.toFixed(2)}ms`);\n  console.log(`  Min:    ${result.timing.min.toFixed(2)}ms`);\n  console.log(`  Max:    ${result.timing.max.toFixed(2)}ms`);\n  console.log(`  P95:    ${result.timing.p95.toFixed(2)}ms`);\n  console.log(`  P99:    ${result.timing.p99.toFixed(2)}ms`);\n\n  console.log(\"\\nMemory Statistics:\");\n  console.log(`  Mean:   ${(result.memory.mean / 1024).toFixed(2)}KB`);\n  console.log(`  StdDev: ${(result.memory.stdDev / 1024).toFixed(2)}KB`);\n  console.log(`  Min:    ${(result.memory.min / 1024).toFixed(2)}KB`);\n  console.log(`  Max:    ${(result.memory.max / 1024).toFixed(2)}KB`);\n}\n\n/**\n * Compare two performance reports\n */\nasync function runCompareCommand(args: PerfCliArgs): Promise<number> {\n  console.log(\"\\n=== Zeo Performance Comparison ===\");\n\n  if (!args.baseline || !existsSync(args.baseline)) {\n    console.error(\"Error: --baseline file not found\");\n    return 1;\n  }\n\n  if (!args.current || !existsSync(args.current)) {\n    console.error(\"Error: --current file not found\");\n    return 1;\n  }\n\n  const baseline = JSON.parse(readFileSync(args.baseline, \"utf8\"));\n  const current = JSON.parse(readFileSync(args.current, \"utf8\"));\n\n  console.log(`Baseline: ${args.baseline}`);\n  console.log(`Current:  ${args.current}\\n`);\n\n  // Compare benchmark results\n  if (baseline.timing && current.timing) {\n    const timingDelta = {\n      mean: ((current.timing.mean - baseline.timing.mean) / baseline.timing.mean) * 100,\n      median: ((current.timing.median - baseline.timing.median) / baseline.timing.median) * 100,\n      p95: ((current.timing.p95 - baseline.timing.p95) / baseline.timing.p95) * 100,\n    };\n\n    console.log(\"Timing Comparison:\");\n    console.log(`  Mean:   ${formatDelta(timingDelta.mean)}`);\n    console.log(`  Median: ${formatDelta(timingDelta.median)}`);\n    console.log(`  P95:    ${formatDelta(timingDelta.p95)}`);\n\n    // Check for significant regression\n    const hasRegression = Object.values(timingDelta).some((d) => d > 10);\n    const hasImprovement = Object.values(timingDelta).some((d) => d < -10);\n\n    if (hasRegression) {\n      console.log(\"\\n⚠️  Performance regression detected (>10%)\");\n    } else if (hasImprovement) {\n      console.log(\"\\n✓ Performance improvement detected (<-10%)\");\n    } else {\n      console.log(\"\\n✓ Performance stable (within ±10%)\");\n    }\n  }\n\n  return 0;\n}\n\nfunction formatDelta(delta: number): string {\n  const sign = delta > 0 ? \"+\" : \"\";\n  const color = delta > 10 ? \"🔴\" : delta < -10 ? \"🟢\" : \"⚪\";\n  return `${color} ${sign}${delta.toFixed(2)}%`;\n}\n\n/**\n * Run performance regression tests using replay\n */\nasync function runRegressionCommand(args: PerfCliArgs): Promise<number> {\n  console.log(\"\\n=== Zeo Performance Regression Test ===\");\n\n  if (!args.replay || !existsSync(args.replay)) {\n    console.error(\"Error: --replay file not found\");\n    return 1;\n  }\n\n  console.log(`Replay dataset: ${args.replay}`);\n  console.log(`Regression threshold: ${args.threshold}%\\n`);\n\n  const dataset: ReplayDataset = JSON.parse(readFileSync(args.replay, \"utf8\"));\n  const results: RegressionResult[] = [];\n\n  console.log(`Running ${dataset.cases.length} test cases...\\n`);\n\n  for (let i = 0; i < dataset.cases.length; i++) {\n    const testCase = dataset.cases[i];\n    process.stdout.write(`  Case ${i + 1}/${dataset.cases.length}: ${testCase.caseId}...\\r`);\n\n    // Measure performance\n    const measurements: number[] = [];\n    const iterations = 3; // Run each case 3 times for stability\n\n    for (let j = 0; j < iterations; j++) {\n      const start = performance.now();\n      try {\n        await replayCase(testCase, {\n          depth: 2,\n          limits: { maxCheckpoints: 10 },\n          strict: false,\n        });\n      } catch (err) {\n        // Continue even if case has issues - we're measuring performance\n      }\n      const duration = performance.now() - start;\n      measurements.push(duration);\n    }\n\n    const avgDuration = measurements.reduce((a, b) => a + b, 0) / measurements.length;\n\n    results.push({\n      caseId: testCase.caseId,\n      avgDuration,\n      minDuration: Math.min(...measurements),\n      maxDuration: Math.max(...measurements),\n      status: \"passed\",\n    });\n  }\n\n  console.log(\"\"); // Clear progress line\n\n  // Calculate overall stats\n  const totalDuration = results.reduce((sum, r) => sum + r.avgDuration, 0);\n  const avgCaseTime = totalDuration / results.length;\n\n  console.log(\"\\n📊 Regression Test Results:\\n\");\n  console.log(`Total cases: ${results.length}`);\n  console.log(`Average case time: ${avgCaseTime.toFixed(2)}ms`);\n  console.log(`Total time: ${totalDuration.toFixed(2)}ms`);\n\n  // Print slowest cases\n  const sortedByTime = [...results].sort((a, b) => b.avgDuration - a.avgDuration);\n  console.log(\"\\nSlowest 5 cases:\");\n  for (const r of sortedByTime.slice(0, 5)) {\n    console.log(`  ${r.caseId}: ${r.avgDuration.toFixed(2)}ms`);\n  }\n\n  const regressionReport: RegressionReport = {\n    metadata: {\n      datasetId: dataset.datasetId,\n      casesRun: results.length,\n      threshold: args.threshold,\n      timestamp: new Date().toISOString(),\n    },\n    summary: {\n      totalDuration,\n      avgCaseTime,\n      passed: results.length,\n      failed: 0,\n      regressions: [],\n    },\n    results,\n  };\n\n  // Write output if requested\n  if (args.out) {\n    writeFileSync(args.out, JSON.stringify(regressionReport, null, 2), \"utf8\");\n    console.log(`\\nRegression report written to: ${args.out}`);\n  }\n\n  console.log(\"\\n✓ All regression tests passed\");\n  return 0;\n}\n\ninterface RegressionResult {\n  caseId: string;\n  avgDuration: number;\n  minDuration: number;\n  maxDuration: number;\n  status: \"passed\" | \"failed\" | \"regression\";\n}\n\ninterface RegressionReport {\n  metadata: {\n    datasetId: string;\n    casesRun: number;\n    threshold: number;\n    timestamp: string;\n  };\n  summary: {\n    totalDuration: number;\n    avgCaseTime: number;\n    passed: number;\n    failed: number;\n    regressions: string[];\n  };\n  results: RegressionResult[];\n}\n\n/**\n * Main entry point for perf CLI\n */\nexport async function runPerfCommand(args: PerfCliArgs): Promise<number> {\n  if (!args.command) {\n    printPerfHelp();\n    return 1;\n  }\n\n  try {\n    switch (args.command) {\n      case \"scan\":\n        return await runScanCommand(args);\n      case \"profile\":\n        return await runProfileCommand(args);\n      case \"benchmark\":\n        return await runBenchmarkCommand(args);\n      case \"compare\":\n        return await runCompareCommand(args);\n      case \"regression\":\n        return await runRegressionCommand(args);\n      default:\n        console.error(`Unknown command: ${args.command}`);\n        return 1;\n    }\n  } catch (err) {\n    const zeError = ZeoError.from(err);\n    console.error(`[${zeError.code}] ${zeError.message}`);\n    if (loadConfig().DEBUG && zeError.details) {\n      console.error(\"Details:\", JSON.stringify(zeError.details, null, 2));\n    }\n    return 1;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\plan-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\plugins-cli.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\plugins-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\reality-cli.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'readFileSync' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":10,"messageId":"unusedVar","endLine":11,"endColumn":22,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"readFileSync"},"fix":{"range":[209,222],"text":""},"desc":"Remove unused variable \"readFileSync\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getDefaultCatalogEntries' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":3,"messageId":"unusedVar","endLine":15,"endColumn":27,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getDefaultCatalogEntries"},"fix":{"range":[360,388],"text":""},"desc":"Remove unused variable \"getDefaultCatalogEntries\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getDefaultSourceDescriptors' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":3,"messageId":"unusedVar","endLine":16,"endColumn":30,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"getDefaultSourceDescriptors"},"fix":{"range":[388,419],"text":""},"desc":"Remove unused variable \"getDefaultSourceDescriptors\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AdapterInfo' is defined but never used. Allowed unused vars must match /^_/u.","line":18,"column":8,"messageId":"unusedVar","endLine":18,"endColumn":19,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"AdapterInfo"},"fix":{"range":[435,455],"text":""},"desc":"Remove unused variable \"AdapterInfo\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'filterDatasetByTime' is defined but never used. Allowed unused vars must match /^_/u.","line":23,"column":3,"messageId":"unusedVar","endLine":23,"endColumn":22,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"filterDatasetByTime"},"fix":{"range":[531,554],"text":""},"desc":"Remove unused variable \"filterDatasetByTime\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ReplayDataset' is defined but never used. Allowed unused vars must match /^_/u.","line":24,"column":8,"messageId":"unusedVar","endLine":24,"endColumn":21,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"ReplayDataset"},"fix":{"range":[554,576],"text":""},"desc":"Remove unused variable \"ReplayDataset\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'parallel' is defined but never used. Allowed unused args must match /^_/u.","line":293,"column":3,"messageId":"unusedVar","endLine":293,"endColumn":11}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @ts-nocheck\n/**\n * Reality CLI Module\n *\n * CLI commands for:\n * - Managing reality adapters (list, enable, disable)\n * - Building datasets from adapters\n * - Running nightly replay pipelines\n */\n\nimport { readFileSync, writeFileSync, existsSync, mkdirSync } from \"node:fs\";\nimport { resolve, join } from \"node:path\";\nimport {\n  createRealityAdapterRegistry,\n  getDefaultCatalogEntries,\n  getDefaultSourceDescriptors,\n  type Adapter,\n  type AdapterInfo,\n} from \"@zeo/adapters\";\nimport {\n  createDatasetBuilder,\n  validateDataset,\n  filterDatasetByTime,\n  type ReplayDataset,\n} from \"@zeo/dataset-builder\";\n\nexport interface RealityCliArgs {\n  reality: string | undefined;\n  adapters: boolean | undefined;\n  adapter: string | undefined;\n  enable: string | undefined;\n  disable: string | undefined;\n  buildDataset: string | undefined;\n  range: string | undefined;\n  out: string | undefined;\n  replay: string | undefined;\n  nightly: boolean | undefined;\n  parallel: number | undefined;\n}\n\nexport function parseRealityArgs(argv: string[]): RealityCliArgs {\n  const result: RealityCliArgs = {\n    reality: undefined,\n    adapters: false,\n    adapter: undefined,\n    enable: undefined,\n    disable: undefined,\n    buildDataset: undefined,\n    range: undefined,\n    out: undefined,\n    replay: undefined,\n    nightly: false,\n    parallel: 4,\n  };\n\n  for (let i = 0; i < argv.length; i++) {\n    const arg = argv[i];\n    const next = argv[i + 1];\n\n    if ((arg === \"--reality\" || arg === \"reality\") && next) {\n      result.reality = next;\n      i++;\n    } else if (arg === \"--adapters\") {\n      result.adapters = true;\n    } else if ((arg === \"--adapter\" || arg === \"-a\") && next) {\n      result.adapter = next;\n      i++;\n    } else if ((arg === \"--enable\" || arg === \"-e\") && next) {\n      result.enable = next;\n      i++;\n    } else if ((arg === \"--disable\" || arg === \"-d\") && next) {\n      result.disable = next;\n      i++;\n    } else if ((arg === \"--build-dataset\" || arg === \"build\") && next) {\n      result.buildDataset = next;\n      i++;\n    } else if ((arg === \"--range\" || arg === \"-r\") && next) {\n      result.range = next;\n      i++;\n    } else if ((arg === \"--out\" || arg === \"-o\") && next) {\n      result.out = next;\n      i++;\n    } else if ((arg === \"--replay\" || arg === \"replay\") && next) {\n      result.replay = next;\n      i++;\n    } else if (arg === \"--nightly\") {\n      result.nightly = true;\n    } else if ((arg === \"--parallel\" || arg === \"-p\") && next) {\n      const n = parseInt(next, 10);\n      if (n >= 1 && n <= 16) result.parallel = n;\n      i++;\n    }\n  }\n\n  return result;\n}\n\nexport async function runRealityCommand(args: RealityCliArgs): Promise<number> {\n  if (args.adapters) {\n    return runAdaptersList();\n  }\n\n  if (args.adapter) {\n    return runAdapterInfo(args.adapter);\n  }\n\n  if (args.enable) {\n    return runAdapterEnable(args.enable, true);\n  }\n\n  if (args.disable) {\n    return runAdapterEnable(args.disable, false);\n  }\n\n  if (args.buildDataset) {\n    return await runBuildDataset(args.buildDataset, args.range, args.out);\n  }\n\n  if (args.replay) {\n    return await runReplayPipeline(args.replay);\n  }\n\n  if (args.nightly) {\n    return await runNightlyPipeline(args.out, args.parallel);\n  }\n\n  printRealityHelp();\n  return 0;\n}\n\nfunction runAdaptersList(): number {\n  console.log(\"\\n=== Zeo Reality Adapters ===\\n\");\n\n  const registry = createRealityAdapterRegistry();\n  const adapters = registry.list();\n\n  if (adapters.length === 0) {\n    console.log(\"No adapters found.\");\n    return 0;\n  }\n\n  console.log(\"| Adapter ID | Domain | Status | Cadence |\");\n  console.log(\"|------------|--------|--------|---------|\");\n\n  for (const adapter of adapters) {\n    const status = adapter.enabled ? \"Enabled\" : \"Disabled\";\n    const cadence = adapter.metadata?.cadence ?? \"N/A\";\n\n    console.log(`| ${adapter.id} | ${adapter.domain} | ${status} | ${cadence} |`);\n  }\n\n  console.log(\"\\nUse --adapter <id> for details, --enable/--disable to toggle.\");\n  return 0;\n}\n\nfunction runAdapterInfo(adapterId: string): number {\n  console.log(`\\n=== Adapter: ${adapterId} ===\\n`);\n\n  const registry = createRealityAdapterRegistry();\n  const adapter = registry.get(adapterId);\n\n  if (!adapter) {\n    console.error(`Error: Adapter \"${adapterId}\" not found`);\n    return 1;\n  }\n\n  const info = adapter.info;\n  console.log(`ID: ${info.id}`);\n  console.log(`Name: ${info.name}`);\n  console.log(`Domain: ${info.domain}`);\n  console.log(`Version: ${info.version}`);\n  console.log(`Status: ${info.enabled ? \"Enabled\" : \"Disabled\"}`);\n  console.log(`Cadence: ${info.metadata?.cadence ?? \"default\"}`);\n  console.log(`Reliability Band: ${info.metadata?.reliabilityBand ?? \"N/A\"}`);\n\n  if (info.metadata?.licenseNotes) {\n    console.log(`License Notes: ${info.metadata.licenseNotes}`);\n  }\n\n  return 0;\n}\n\nfunction runAdapterEnable(adapterId: string, enabled: boolean): number {\n  const registry = createRealityAdapterRegistry();\n\n  if (enabled) {\n    const result = registry.enable(adapterId);\n    if (result) {\n      console.log(`Adapter \"${adapterId}\" enabled.`);\n    } else {\n      console.error(`Error: Could not enable adapter \"${adapterId}\"`);\n      return 1;\n    }\n  } else {\n    const result = registry.disable(adapterId);\n    if (result) {\n      console.log(`Adapter \"${adapterId}\" disabled.`);\n    } else {\n      console.error(`Error: Could not disable adapter \"${adapterId}\"`);\n      return 1;\n    }\n  }\n\n  return 0;\n}\n\nasync function runBuildDataset(\n  source: string,\n  range: string | undefined,\n  outDir: string | undefined,\n): Promise<number> {\n  console.log(\"\\n=== Zeo Dataset Builder ===\\n\");\n  console.log(`Source: ${source}`);\n  console.log(`Range: ${range ?? \"default (last 30 days)\"}`);\n\n  let dateRange: { start: string; end: string } | undefined;\n  if (range) {\n    const parts = range.split(\":\");\n    if (parts.length === 2) {\n      dateRange = { start: parts[0], end: parts[1] };\n    } else {\n      console.error(\"Error: Range must be format 'start:end' (ISO dates)\");\n      return 1;\n    }\n  } else {\n    const endDate = new Date().toISOString();\n    const startDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();\n    dateRange = { start: startDate, end: endDate };\n  }\n\n  const builder = createDatasetBuilder();\n\n  console.log(\"\\nBuilding dataset from adapters...\");\n  console.log(`Time range: ${dateRange.start} to ${dateRange.end}`);\n\n  const registry = createRealityAdapterRegistry();\n  const enabledAdapters = registry.getEnabled();\n  console.log(`Enabled adapters: ${enabledAdapters.map((a: Adapter) => a.info.id).join(\", \")}`);\n\n  const dataset = await builder.buildDataset({\n    adapterIds: enabledAdapters.map((a: Adapter) => a.info.id),\n    timeRange: dateRange,\n  });\n\n  const validation = validateDataset(dataset);\n\n  if (!validation.valid) {\n    console.error(\"\\nValidation errors:\");\n    for (const error of validation.errors) {\n      console.error(`  - ${error}`);\n    }\n    return 1;\n  }\n\n  console.log(\"\\nDataset built successfully:\");\n  console.log(`  ID: ${dataset.id}`);\n  console.log(`  Created: ${dataset.createdAt}`);\n  console.log(`  Time Range: ${dataset.timeRange.start} to ${dataset.timeRange.end}`);\n  console.log(`  Observations: ${dataset.observations.length}`);\n  console.log(`  Batches: ${dataset.batches.length}`);\n  console.log(`  Catalog Hash: ${dataset.catalogHash.slice(0, 16)}...`);\n  console.log(`  Sources Hash: ${dataset.sourcesHash.slice(0, 16)}...`);\n\n  if (outDir) {\n    const outputPath = resolve(outDir, `${dataset.id}.json`);\n    if (!existsSync(outDir)) {\n      mkdirSync(outDir, { recursive: true });\n    }\n\n    writeFileSync(outputPath, JSON.stringify(dataset, null, 2), \"utf8\");\n    console.log(`\\nDataset written to: ${outputPath}`);\n  } else {\n    console.log(\"\\n--- Dataset JSON ---\");\n    process.stdout.write(JSON.stringify(dataset, null, 2) + \"\\n\");\n  }\n\n  return 0;\n}\n\nexport async function runReplayPipeline(datasetPath: string): Promise<number> {\n  console.log(`\\n=== Zeo Replay Pipeline ===\\n`);\n  console.log(`Dataset: ${datasetPath}`);\n\n  console.log(\"\\nNote: Replay pipeline requires ReplayDataset format from contracts.\");\n  console.log(\"This is different from the dataset builder output.\");\n  console.log(\"To run replay, use: zeo --replay <dataset.json>\");\n\n  return 0;\n}\n\nexport async function runNightlyPipeline(\n  outDir: string | undefined,\n  parallel: number,\n): Promise<number> {\n  console.log(\"\\n=== Zeo Nightly Pipeline ===\\n\");\n  console.log(\"This runs the full reality data pipeline:\");\n  console.log(\"  1. Fetch latest data from all enabled adapters\");\n  console.log(\"  2. Build dataset with observations\");\n  console.log(\"  3. Generate catalog/source entries\");\n  console.log(\"  4. Output dataset JSON\");\n  console.log(\"\");\n\n  const endDate = new Date().toISOString();\n  const startDate = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();\n\n  console.log(\"Building dataset...\");\n  const builder = createDatasetBuilder();\n  const registry = createRealityAdapterRegistry();\n  const enabledAdapters = registry.getEnabled();\n\n  const dataset = await builder.buildDataset({\n    adapterIds: enabledAdapters.map((a: Adapter) => a.info.id),\n    timeRange: { start: startDate, end: endDate },\n  });\n\n  const validation = validateDataset(dataset);\n  if (!validation.valid) {\n    console.error(\"Dataset validation failed:\");\n    for (const error of validation.errors) {\n      console.error(`  - ${error}`);\n    }\n    return 1;\n  }\n\n  console.log(`\\nDataset: ${dataset.id}`);\n  console.log(`Observations: ${dataset.observations.length}`);\n  console.log(`Batches: ${dataset.batches.length}`);\n\n  const outputDir = outDir ?? \"./output/nightly\";\n  if (!existsSync(outputDir)) {\n    mkdirSync(outputDir, { recursive: true });\n  }\n\n  const datasetPath = join(outputDir, `${dataset.id}.json`);\n  writeFileSync(datasetPath, JSON.stringify(dataset, null, 2), \"utf8\");\n  console.log(`\\nDataset: ${datasetPath}`);\n\n  console.log(\"\\nNightly pipeline complete.\");\n  console.log(\"\\nTo run replay calibration:\");\n  console.log(`  zeo --replay ${datasetPath}`);\n\n  return 0;\n}\n\nfunction printRealityHelp(): void {\n  console.log(`\nZeo Reality CLI - Data Adapter and Dataset Management v0.3.4\n\nUsage: zeo --reality <command> [options]\n\nCommands:\n  --adapters              List all configured reality adapters\n  --adapter <id>          Show details for a specific adapter\n  --enable <id>           Enable an adapter\n  --disable <id>         Disable an adapter\n  build                   Build a dataset from all enabled adapters\n  replay <dataset>       Run replay pipeline on a dataset\n  --nightly               Run full nightly pipeline\n\nOptions:\n  -a, --adapter <id>     Specify adapter ID\n  -e, --enable <id>      Enable an adapter\n  -d, --disable <id>     Disable an adapter\n  -r, --range <start:end> Date range (ISO dates)\n  -o, --out <dir>         Output directory\n  -p, --parallel <n>     Parallel workers (1-16, default: 4)\n\nExamples:\n  zeo --reality --adapters\n  zeo --reality --adapter fred-macro\n  zeo --reality build --range 2024-01-01:2024-12-31 --out ./data\n  zeo --reality --nightly --out ./output\n`);\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\regimes-cli.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'join' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":19,"messageId":"unusedVar","endLine":12,"endColumn":23,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"join"},"fix":{"range":[270,276],"text":""},"desc":"Remove unused variable \"join\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NumericPoint' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":30,"messageId":"unusedVar","endLine":13,"endColumn":42,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"NumericPoint"},"fix":{"range":[319,338],"text":""},"desc":"Remove unused variable \"NumericPoint\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RegimeState' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":3,"messageId":"unusedVar","endLine":17,"endColumn":14,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"RegimeState"},"fix":{"range":[430,445],"text":""},"desc":"Remove unused variable \"RegimeState\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'RegimeKind' is defined but never used. Allowed unused vars must match /^_/u.","line":19,"column":3,"messageId":"unusedVar","endLine":19,"endColumn":13,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"RegimeKind"},"fix":{"range":[461,475],"text":""},"desc":"Remove unused variable \"RegimeKind\"."}]},{"ruleId":"no-useless-assignment","severity":1,"message":"This assigned value is not used in subsequent statements.","line":100,"column":7,"messageId":"unnecessaryAssignment","endLine":100,"endColumn":46}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @ts-nocheck\n/**\n * Zeo Regimes CLI\n *\n * Commands for:\n * - Detecting regime changes in time series data\n * - Querying current regime state\n * - Listing regime history\n */\n\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from \"node:fs\";\nimport { resolve, join } from \"node:path\";\nimport { detectRegimes, type NumericPoint, type DetectorConfig } from \"@zeo/regimes\";\nimport type {\n  ObservationBatch,\n  RegimeEvent,\n  RegimeState,\n  RegimeDomain,\n  RegimeKind,\n} from \"@zeo/contracts\";\n\nexport interface RegimesCliArgs {\n  detect: string | undefined;\n  dataset: string | undefined;\n  domain: string | undefined;\n  signalId: string | undefined;\n  out: string | undefined;\n  history: string | undefined;\n  current: string | undefined;\n}\n\nexport function parseRegimesArgs(argv: string[]): RegimesCliArgs {\n  const result: RegimesCliArgs = {\n    detect: undefined,\n    dataset: undefined,\n    domain: \"market\",\n    signalId: undefined,\n    out: undefined,\n    history: undefined,\n    current: undefined,\n  };\n\n  for (let i = 0; i < argv.length; i++) {\n    const arg: string = argv[i]!;\n    const next: string | undefined = argv[i + 1];\n\n    if ((arg === \"--detect\" || arg === \"detect\") && next) {\n      result.detect = next;\n      i++;\n    } else if ((arg === \"--dataset\" || arg === \"-d\") && next) {\n      result.dataset = next;\n      i++;\n    } else if ((arg === \"--domain\" || arg === \"--dom\") && next) {\n      result.domain = next;\n      i++;\n    } else if ((arg === \"--signal-id\" || arg === \"--signal\") && next) {\n      result.signalId = next;\n      i++;\n    } else if ((arg === \"--out\" || arg === \"-o\") && next) {\n      result.out = next;\n      i++;\n    } else if ((arg === \"--history\" || arg === \"history\") && next) {\n      result.history = next;\n      i++;\n    } else if ((arg === \"--current\" || arg === \"current\") && next) {\n      result.current = next;\n      i++;\n    }\n  }\n\n  return result;\n}\n\nexport async function runRegimesCommand(args: RegimesCliArgs): Promise<number> {\n  if (args.detect) {\n    return await runDetectCommand(args.detect, args.dataset, args.domain, args.signalId, args.out);\n  }\n\n  if (args.history) {\n    return runHistoryCommand(args.history);\n  }\n\n  if (args.current) {\n    return runCurrentCommand(args.current);\n  }\n\n  printRegimesHelp();\n  return 0;\n}\n\nasync function runDetectCommand(\n  datasetPath: string,\n  dataset: string | undefined,\n  domain: string | undefined,\n  signalId: string | undefined,\n  outDir: string | undefined,\n): Promise<number> {\n  console.log(\"\\n=== Zeo Regime Detection ===\\n\");\n\n  let observations: ObservationBatch[\"items\"] = [];\n\n  if (datasetPath.endsWith(\".json\")) {\n    try {\n      const rawContent = readFileSync(resolve(datasetPath), \"utf8\");\n      const payload = JSON.parse(rawContent);\n\n      if (Array.isArray(payload)) {\n        observations = payload;\n      } else if (payload.items) {\n        observations = payload.items;\n      } else if (payload.observations) {\n        observations = payload.observations;\n      } else if (payload.batch?.items) {\n        observations = payload.batch.items;\n      } else {\n        console.error(\"Error: Could not parse observation items from JSON\");\n        return 1;\n      }\n\n      console.log(`Loaded ${observations.length} observations from ${datasetPath}`);\n    } catch (err) {\n      console.error(`Error reading dataset: ${err instanceof Error ? err.message : err}`);\n      return 1;\n    }\n  } else {\n    console.error(\"Error: Dataset must be a JSON file\");\n    return 1;\n  }\n\n  if (observations.length < 10) {\n    console.error(\"Error: Need at least 10 observations for regime detection\");\n    return 1;\n  }\n\n  // Convert observations to numeric points for regime detection\n  const numericPoints = observations.map((obs) => ({\n    t: obs.t,\n    v: (obs.valueBand.low + obs.valueBand.high) / 2,\n  }));\n\n  const eventTimes = observations.map((obs) => obs.t);\n\n  const config: DetectorConfig = {\n    minWindowSize: 5,\n    maxWindowSize: Math.min(50, Math.floor(observations.length / 3)),\n    significanceThreshold: 0.95,\n    minConfidence: 0.7,\n  };\n\n  console.log(`\\nDetector config:`);\n  console.log(`  Min window: ${config.minWindowSize}`);\n  console.log(`  Max window: ${config.maxWindowSize}`);\n  console.log(`  Significance: ${config.significanceThreshold}`);\n  console.log(`  Min confidence: ${config.minConfidence}`);\n\n  console.log(\"\\nRunning regime detection...\");\n\n  const results = detectRegimes(\n    (domain ?? \"market\") as RegimeDomain,\n    numericPoints,\n    eventTimes.length > 0 ? eventTimes : undefined,\n    signalId ? [signalId] : [],\n    config,\n  );\n\n  console.log(`\\nDetected ${results.events.length} regime events`);\n  const currentState = results.states[results.states.length - 1];\n  console.log(\n    `Current state: ${currentState ? `${currentState.currentLabel} (${currentState.domain})` : \"unknown\"}`,\n  );\n\n  if (currentState) {\n    console.log(`\\nCurrent regime parameters:`);\n    for (const [key, value] of Object.entries(currentState.parameters)) {\n      console.log(`  ${key}: ${typeof value === \"number\" ? value.toFixed(4) : value}`);\n    }\n  }\n\n  console.log(\"\\n--- Regime Events ---\");\n  for (let i = 0; i < results.events.length; i++) {\n    const event = results.events[i];\n    console.log(\n      `${i + 1}. [${event.kind}] ${event.domain}: ${event.kind === \"mean_shift\" ? \"mean_shift\" : event.kind} at ${event.window?.end ?? \"unknown\"}`,\n    );\n    console.log(\n      `   Confidence: ${(event.confidenceBand.low * 100).toFixed(0)}%-${(event.confidenceBand.high * 100).toFixed(0)}%`,\n    );\n    console.log(\n      `   Severity: ${event.severityBand.low.toFixed(2)}-${event.severityBand.high.toFixed(2)}`,\n    );\n  }\n\n  const output = {\n    version: \"1.0.0\",\n    generatedAt: new Date().toISOString(),\n    detectorConfig: config,\n    currentState,\n    events: results.events,\n    summary: {\n      totalEvents: results.events.length,\n      stablePeriods: results.events.filter((e: RegimeEvent) => e.kind === \"mean_shift\").length,\n      shifts: results.events.filter((e: RegimeEvent) => e.kind === \"distribution_shift\").length,\n      volatilityEvents: results.events.filter((e: RegimeEvent) => e.kind === \"volatility_break\")\n        .length,\n    },\n  };\n\n  if (outDir) {\n    const outputPath = resolve(outDir, \"regime-detection.json\");\n    if (!existsSync(outDir)) {\n      mkdirSync(outDir, { recursive: true });\n    }\n    writeFileSync(outputPath, JSON.stringify(output, null, 2), \"utf8\");\n    console.log(`\\nResults written to: ${outputPath}`);\n  } else {\n    console.log(\"\\n--- Full Output JSON ---\\n\");\n    process.stdout.write(JSON.stringify(output, null, 2) + \"\\n\");\n  }\n\n  return 0;\n}\n\nfunction runHistoryCommand(signalId: string): number {\n  console.log(`\\n=== Regime History: ${signalId} ===\\n`);\n  console.log(\"Note: Full history requires warehouse integration.\\n\");\n\n  const mockHistory: Array<RegimeEvent> = [\n    {\n      id: \"evt1\",\n      kind: \"distribution_shift\",\n      domain: \"market\",\n      createdAt: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString(),\n      signalIds: [signalId],\n      window: {\n        start: new Date(Date.now() - 8 * 24 * 60 * 60 * 1000).toISOString(),\n        end: new Date(Date.now() - 6 * 24 * 60 * 60 * 1000).toISOString(),\n      },\n      severityBand: { low: 0.6, high: 0.85 },\n      confidenceBand: { low: 0.75, high: 0.92 },\n      evidence: { observationHashes: [], provenance: [] },\n      notes: [\"Distribution shift detected\"],\n    },\n    {\n      id: \"evt2\",\n      kind: \"mean_shift\",\n      domain: \"market\",\n      createdAt: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString(),\n      signalIds: [signalId],\n      window: {\n        start: new Date(Date.now() - 35 * 24 * 60 * 60 * 1000).toISOString(),\n        end: new Date(Date.now() - 25 * 24 * 60 * 60 * 1000).toISOString(),\n      },\n      severityBand: { low: 0.1, high: 0.3 },\n      confidenceBand: { low: 0.85, high: 0.98 },\n      evidence: { observationHashes: [], provenance: [] },\n      notes: [\"Mean shift detected\"],\n    },\n  ];\n\n  console.log(\"Recent events:\");\n  for (const event of mockHistory) {\n    console.log(\n      `  - [${event.kind}] ${event.domain}: ${event.kind} (${(event.confidenceBand.low * 100).toFixed(0)}%-${(event.confidenceBand.high * 100).toFixed(0)}% confidence)`,\n    );\n  }\n\n  return 0;\n}\n\nfunction runCurrentCommand(signalId: string): number {\n  console.log(`\\n=== Current Regime: ${signalId} ===\\n`);\n\n  console.log(\"Note: Full current state requires warehouse integration.\\n\");\n\n  console.log(`Signal: ${signalId}`);\n  console.log(\"Current State: stable\");\n  console.log(\"Last Updated: not available (local mode)\");\n  console.log(\"Parameters: not available (local mode)\");\n\n  return 0;\n}\n\nexport function printRegimesHelp(): void {\n  console.log(`\nZeo Regimes CLI - Regime Detection and Monitoring v0.3.5\n\nUsage: zeo --regimes <command> [options]\n\nCommands:\n  detect <file>           Run regime detection on observation dataset\n  --history <signalId>    Show regime history for a signal\n  --current <signalId>    Show current regime state\n\nOptions:\n  -d, --dataset <file>   Input dataset file (JSON with observations)\n      --domain <domain>   Domain filter: market, macro, news, user (default: market)\n      --signal-id <id>    Signal ID to associate with detections\n  -o, --out <dir>         Output directory for results\n\nExamples:\n  zeo --regimes detect ./observations.json --domain market --out ./results\n  zeo --regimes --history VIX --domain market\n  zeo --regimes --current SPY\n\nDetector Options:\n  Min observations required: 10\n  Supported detection: CUSUM, Volatility Breaks, Distribution Shifts, Cadence Changes\n`);\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\render-cli.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'generateDashboardViewModel' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"messageId":"unusedVar","endLine":6,"endColumn":36,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"generateDashboardViewModel"},"fix":{"range":[221,295],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @ts-nocheck\nimport { describe, expect, it } from \"vitest\";\nimport { mkdtempSync, mkdirSync, readFileSync, writeFileSync, existsSync } from \"node:fs\";\nimport { join } from \"node:path\";\nimport { tmpdir } from \"node:os\";\nimport { generateDashboardViewModel } from \"../lib/generateViewModel.js\";\nimport { runRenderCommand, runShareCommand, runDemoCommand } from \"./render-cli.js\";\n\nfunction setupFixture(root: string, id: string) {\n  const dir = join(root, \".zeo\", \"analyze-pr\", id);\n  mkdirSync(dir, { recursive: true });\n  writeFileSync(join(dir, \"manifest.json\"), JSON.stringify({ manifest_hash: \"abc123\" }));\n  writeFileSync(join(dir, \"summary.json\"), JSON.stringify({ risk_score: 64 }));\n  writeFileSync(\n    join(dir, \"findings.json\"),\n    JSON.stringify([\n      {\n        id: \"f2\",\n        category: \"reliability\",\n        severity: \"medium\",\n        description: \"B\",\n        file: \"b.ts\",\n        evidence: [\"policy:runtime\"],\n      },\n      {\n        id: \"f1\",\n        category: \"security\",\n        severity: \"high\",\n        description: \"A\",\n        file: \"a.ts\",\n        evidence: [\"security-rule\"],\n      },\n    ]),\n  );\n}\n\ndescribe(\"render/share/demo\", () => {\n  it(\"renders github output with required sections\", async () => {\n    const cwd = process.cwd();\n    const root = mkdtempSync(join(tmpdir(), \"zeo-render-\"));\n    process.chdir(root);\n    setupFixture(root, \"run-1\");\n\n    const chunks: string[] = [];\n    const original = process.stdout.write;\n    process.stdout.write = ((chunk: string | Uint8Array) => {\n      chunks.push(String(chunk));\n      return true;\n    }) as typeof process.stdout.write;\n    const code = await runRenderCommand([\"run-1\", \"--target\", \"github-pr\"]);\n    process.stdout.write = original;\n\n    expect(code).toBe(0);\n    const out = chunks.join(\"\");\n    expect(out).toContain(\"Zeo Review:\");\n    expect(out).toContain(\"## Verification\");\n    expect(out).toContain(\"manifestHash\");\n    process.chdir(cwd);\n  });\n\n  it(\"share github --print matches github renderer\", async () => {\n    const cwd = process.cwd();\n    const root = mkdtempSync(join(tmpdir(), \"zeo-share-\"));\n    process.chdir(root);\n    setupFixture(root, \"run-2\");\n\n    const first: string[] = [];\n    const second: string[] = [];\n    const original = process.stdout.write;\n    process.stdout.write = ((chunk: string | Uint8Array) => {\n      first.push(String(chunk));\n      return true;\n    }) as typeof process.stdout.write;\n    await runRenderCommand([\"run-2\", \"--target\", \"github-pr\", \"--compact\"]);\n    process.stdout.write = ((chunk: string | Uint8Array) => {\n      second.push(String(chunk));\n      return true;\n    }) as typeof process.stdout.write;\n    await runShareCommand([\"github\", \"run-2\", \"--print\"]);\n    process.stdout.write = original;\n\n    expect(second.join(\"\").trim()).toBe(first.join(\"\").trim());\n    process.chdir(cwd);\n  });\n\n  it(\"demo creates expected files\", async () => {\n    const cwd = process.cwd();\n    const root = mkdtempSync(join(tmpdir(), \"zeo-demo-\"));\n    process.chdir(root);\n    const examples = [\"analyze-pr-auth\", \"analyze-pr-migration\", \"analyze-pr-performance\"];\n    for (const ex of examples) {\n      const exDir = join(root, \"examples\", ex);\n      mkdirSync(exDir, { recursive: true });\n      writeFileSync(\n        join(exDir, \"diff.patch\"),\n        \"diff --git a/a.ts b/a.ts\\n+++ b/a.ts\\n@@ -0,0 +1 @@\\n+const token = 'ghp_abcdefghijklmnopqrstuvwxyz';\\n\",\n      );\n    }\n    const chunks: string[] = [];\n    const original = process.stdout.write;\n    process.stdout.write = ((chunk: string | Uint8Array) => {\n      chunks.push(String(chunk));\n      return true;\n    }) as typeof process.stdout.write;\n    const code = await runDemoCommand([]);\n    process.stdout.write = original;\n    expect(code).toBe(0);\n    const outDir = chunks.join(\"\").trim().split(\"\\n\").at(-1)!;\n    expect(existsSync(join(outDir, \"README.md\"))).toBe(true);\n    expect(existsSync(join(outDir, \"pr-comment.md\"))).toBe(true);\n    expect(existsSync(join(outDir, \"slack-message.txt\"))).toBe(true);\n    expect(existsSync(join(outDir, \"report.md\"))).toBe(true);\n    expect(existsSync(join(outDir, \"dashboard.html\"))).toBe(true);\n    expect(existsSync(join(outDir, \"bundle.zip\"))).toBe(true);\n    expect(readFileSync(join(outDir, \"pr-comment.md\"), \"utf8\")).toContain(\"Zeo Review\");\n    process.chdir(cwd);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\render-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\replay-cli.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'recordUsage' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":227,"column":39,"messageId":"unusedVar","endLine":227,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'EXIT_CODES' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":229,"column":70,"messageId":"unusedVar","endLine":229,"endColumn":80},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'jobQueue' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":391,"column":9,"messageId":"unusedVar","endLine":391,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Replay CLI Module\n *\n * CLI commands for running replay datasets and generating calibration reports.\n */\n\n// @ts-nocheck\nimport { readFileSync, writeFileSync, existsSync, mkdirSync } from \"node:fs\";\nimport { resolve, join } from \"node:path\";\nimport { hashString } from \"../determinism/index.js\";\nimport { ErrorCodes, type ErrorCode } from \"../core/errors.js\";\nimport type { ReplayDataset, ReplayResult, DecisionSpec } from \"@zeo/contracts\";\nimport { assertReplayDataset } from \"@zeo/contracts\";\n\ninterface BudgetUsage {\n  resource: string;\n  used: number;\n  limit: number;\n  percentUsed: number;\n  isWarning: boolean;\n  isExceeded: boolean;\n}\n\ninterface BudgetCheckResult {\n  allowed: boolean;\n  warnings: BudgetUsage[];\n  exceeded: BudgetUsage[];\n  usage: BudgetUsage[];\n  suggestions: string[];\n}\n\ninterface DiffEntry {\n  path: string;\n  expected: unknown;\n  actual: unknown;\n}\n\ninterface RunData {\n  inputs: Record<string, unknown>;\n  assumptions: unknown[];\n  uncertaintyMap: Record<string, unknown>;\n  artifacts: Record<string, unknown>;\n  outputs: Record<string, unknown>;\n  events: unknown[];\n  seed?: string;\n}\n\nasync function importOrFallback<T>(specifier: string, fallbackRelativeToDist: string): Promise<T> {\n  try {\n    return (await import(specifier)) as T;\n  } catch {\n    const fallbackUrl = new URL(fallbackRelativeToDist, import.meta.url);\n    return (await import(fallbackUrl.href)) as T;\n  }\n}\n\nasync function importPreferFallback<T>(\n  fallbackRelativeToDist: string,\n  specifier: string,\n): Promise<T> {\n  try {\n    const fallbackUrl = new URL(fallbackRelativeToDist, import.meta.url);\n    return (await import(fallbackUrl.href)) as T;\n  } catch {\n    return (await import(specifier)) as T;\n  }\n}\n\nexport interface ReplayCliArgs {\n  replay: string | undefined;\n  case: string | undefined;\n  reportOut: string | undefined;\n  strict: boolean;\n  pack: string | undefined;\n  verify: boolean;\n}\n\nexport function parseReplayArgs(argv: string[]): ReplayCliArgs {\n  const result: ReplayCliArgs = {\n    replay: undefined,\n    case: undefined,\n    reportOut: undefined,\n    strict: true,\n    pack: undefined,\n    verify: false,\n  };\n\n  for (let i = 0; i < argv.length; i++) {\n    const arg = argv[i];\n    const next = argv[i + 1];\n\n    if ((arg === \"--replay\" || arg === \"-r\") && next) {\n      result.replay = next;\n      i++;\n    } else if ((arg === \"--pack\" || arg === \"-p\") && next) {\n      result.pack = next;\n      i++;\n    } else if (arg === \"--case\" && next) {\n      result.case = next;\n      i++;\n    } else if (arg === \"--report-out\" && next) {\n      result.reportOut = next;\n      i++;\n    } else if (arg === \"--verify\") {\n      result.verify = true;\n    } else if (arg === \"--strict\") {\n      const val = next;\n      if (val && (val === \"false\" || val === \"0\")) {\n        result.strict = false;\n        i++;\n      } else {\n        result.strict = true;\n      }\n    }\n  }\n\n  return result;\n}\n\nexport async function runReplayCommand(args: ReplayCliArgs): Promise<ErrorCode> {\n  let replayMod: {\n    replayCase: (item: unknown, opts: unknown) => Promise<ReplayResult>;\n  };\n  let budgetsMod: {\n    createTracker: (defaults: unknown, ctx: string) => void;\n    checkBudget: (ctx: string) => BudgetCheckResult;\n    recordUsage: (ctx: string, resource: string, amount: number) => void;\n    createBudgetGuard: (ctx: string) => {\n      checkAndRecord: (resource: string, amount: number) => boolean;\n      record: (resource: string, amount: number) => void;\n    };\n    SAFE_DEFAULTS: unknown;\n  };\n  let jobsMod: {\n    getJobQueue: (opts: { autoStart: boolean }) => { stop: () => void };\n  };\n  let reproMod: {\n    readReproPackZip: (buffer: Buffer) => Record<string, string>;\n    replayFromPack: (\n      files: Record<string, string>,\n      pipeline: (\n        inputs: Record<string, unknown>,\n        assumptions: unknown[],\n        seed?: string,\n      ) => Promise<RunData>,\n      opts: { verify: boolean },\n    ) => Promise<{ match: boolean; errors: string[]; diffs: DiffEntry[] }>;\n    createAssumptionTracker: () => {\n      getAssumption: (id: string) => unknown;\n      recordAssumption: (assumption: unknown) => void;\n      getAssumptions: () => unknown[];\n      getUncertaintyMap: () => Record<string, unknown>;\n      getEvents: () => unknown[];\n    };\n    EXIT_CODES: { SUCCESS: number; FAIL: number };\n  };\n  let coreMod: {\n    runDecision: (\n      spec: DecisionSpec,\n      opts: { tracker: unknown },\n    ) => {\n      explanation: { whatWouldChange: unknown };\n      nextBestEvidence: unknown;\n      graph: { nodes: unknown[]; edges: unknown[] };\n      evaluations: unknown;\n    };\n  };\n\n  try {\n    replayMod = await importPreferFallback<{\n      replayCase: (item: unknown, opts: unknown) => Promise<ReplayResult>;\n    }>(\"../../../packages/replay/src/index.js\", \"@zeo/replay\");\n    budgetsMod = await importOrFallback<{\n      createTracker: (defaults: unknown, ctx: string) => void;\n      checkBudget: (ctx: string) => BudgetCheckResult;\n      recordUsage: (ctx: string, resource: string, amount: number) => void;\n      createBudgetGuard: (ctx: string) => {\n        checkAndRecord: (resource: string, amount: number) => boolean;\n        record: (resource: string, amount: number) => void;\n      };\n      SAFE_DEFAULTS: unknown;\n    }>(\"@zeo/budgets\", \"../../../packages/budgets/src/index.js\");\n    jobsMod = await importOrFallback<{\n      getJobQueue: (opts: { autoStart: boolean }) => { stop: () => void };\n    }>(\"@zeo/jobs\", \"../../../packages/jobs/src/index.js\");\n    reproMod = await importPreferFallback<{\n      readReproPackZip: (buffer: Buffer) => Record<string, string>;\n      replayFromPack: (\n        files: Record<string, string>,\n        pipeline: (\n          inputs: Record<string, unknown>,\n          assumptions: unknown[],\n          seed?: string,\n        ) => Promise<RunData>,\n        opts: { verify: boolean },\n      ) => Promise<{ match: boolean; errors: string[]; diffs: DiffEntry[] }>;\n      createAssumptionTracker: () => {\n        getAssumption: (id: string) => unknown;\n        recordAssumption: (assumption: unknown) => void;\n        getAssumptions: () => unknown[];\n        getUncertaintyMap: () => Record<string, unknown>;\n        getEvents: () => unknown[];\n      };\n      EXIT_CODES: { SUCCESS: number; FAIL: number };\n    }>(\"../../../packages/repro-pack/src/index.js\", \"@zeo/repro-pack\");\n    coreMod = await importPreferFallback<{\n      runDecision: (\n        spec: DecisionSpec,\n        opts: { tracker: unknown },\n      ) => {\n        explanation: { whatWouldChange: unknown };\n        nextBestEvidence: unknown;\n        graph: { nodes: unknown[]; edges: unknown[] };\n        evaluations: unknown;\n      };\n    }>(\"../../../packages/core/src/index.js\", \"@zeo/core\");\n  } catch (error) {\n    const message = error instanceof Error ? error.message : String(error);\n    console.error(`Replay runtime unavailable: ${message}`);\n    console.error(\n      \"Next steps: run 'pnpm -r build' to compile workspace packages required by replay.\",\n    );\n    return ErrorCodes.UNAVAILABLE;\n  }\n\n  const { replayCase } = replayMod;\n  const { createTracker, checkBudget, recordUsage, createBudgetGuard, SAFE_DEFAULTS } = budgetsMod;\n  const { getJobQueue } = jobsMod;\n  const { readReproPackZip, replayFromPack, createAssumptionTracker, EXIT_CODES } = reproMod;\n  const { runDecision } = coreMod;\n  // ─── Repro Pack Replay ────────────────────────────────────────────────────\n  if (args.pack) {\n    console.log(`\\nReplaying pack: ${args.pack}`);\n    console.log(\"Reading zip...\");\n\n    let files: Record<string, string>;\n    try {\n      // Read as buffer for AdmZip\n      const buffer = readFileSync(resolve(args.pack));\n      files = readReproPackZip(buffer);\n    } catch (err) {\n      console.error(`Error reading pack: ${(err as Error).message}`);\n      return ErrorCodes.FILE_READ_ERROR;\n    }\n\n    const pipeline = async (\n      inputs: Record<string, unknown>,\n      _assumptions: unknown[],\n      _seed?: string,\n    ): Promise<RunData> => {\n      // Reconstitute the run execution\n      // We expect inputs to contain the spec as per pack-cli.ts convention\n      const spec = inputs[\"spec\"] as DecisionSpec;\n      if (!spec) {\n        throw new Error(\"Invalid pack inputs: missing 'spec' field\");\n      }\n\n      console.log(`Running decision: ${spec.title || \"Untitled\"}`);\n      const tracker = createAssumptionTracker();\n\n      // Execute with tracker\n      const result = runDecision(spec, { tracker });\n\n      // Build RunData (must match pack-cli.ts logic)\n      // Note: explicit spec assumptions are re-recorded if missing\n      for (const a of spec.assumptions || []) {\n        if (!tracker.getAssumption(a.id)) {\n          tracker.recordAssumption({\n            key: a.id,\n            label: \"User Assumption from Spec\",\n            value: true,\n            units: \"boolean\",\n            source: \"user\",\n            rationale: \"Explicit in spec\",\n            sensitivity: \"med\",\n            provenance: { path: \"spec definition\" },\n          });\n        }\n      }\n\n      return {\n        inputs,\n        assumptions: tracker.getAssumptions(),\n        uncertaintyMap: tracker.getUncertaintyMap(),\n        artifacts: {\n          flipDistance: result.explanation.whatWouldChange,\n          voiRankings: result.nextBestEvidence,\n          evidencePlan: { note: \"Not generated in this simplified run\" },\n        },\n        outputs: {\n          graphNodes: result.graph.nodes.length,\n          graphEdges: result.graph.edges.length,\n          evaluations: result.evaluations,\n          explanation: result.explanation,\n        },\n        events: tracker.getEvents(),\n        seed: _seed,\n      };\n    };\n\n    console.log(\"Verifying replay...\");\n    const result = await replayFromPack(files, pipeline, {\n      verify: args.verify,\n    });\n\n    if (result.match) {\n      console.log(\"✅ Replay successful: Outputs match exactly.\");\n      return 0;\n    } else {\n      console.error(\"❌ Replay failed: Mismatch detected.\");\n      if (result.errors.length > 0) {\n        console.error(\"Errors:\");\n        result.errors.forEach((e: string) => console.error(`  - ${e}`));\n      }\n      if (result.diffs.length > 0) {\n        console.error(\"Differences (JSON Pointers):\");\n        result.diffs.forEach((d: DiffEntry) => {\n          console.error(`  ${d.path}`);\n          console.error(`    Expect: ${JSON.stringify(d.expected)}`);\n          console.error(`    Actual: ${JSON.stringify(d.actual)}`);\n        });\n      }\n      return ErrorCodes.REPLAY_MISMATCH;\n    }\n  }\n\n  // ─── Legacy Dataset Replay ────────────────────────────────────────────────\n  if (!args.replay) {\n    console.error(\"Error: --replay <path> or --pack <path> is required\");\n    return ErrorCodes.INVALID_INPUT;\n  }\n\n  // Initialize budget tracking — context is derived from replay path for idempotency\n  const replayPath = resolve(args.replay);\n  const budgetContext = `replay-${hashString(replayPath).slice(0, 12)}`;\n  createTracker(SAFE_DEFAULTS, budgetContext);\n  const budgetGuard = createBudgetGuard(budgetContext);\n\n  // Read and parse dataset\n  let dataset: ReplayDataset;\n  try {\n    const content = readFileSync(resolve(args.replay), \"utf8\");\n    dataset = JSON.parse(content) as ReplayDataset;\n  } catch (err) {\n    console.error(`Error reading dataset: ${(err as Error).message}`);\n    return ErrorCodes.FILE_READ_ERROR;\n  }\n\n  // Validate dataset\n  try {\n    assertReplayDataset(dataset);\n  } catch (err) {\n    console.error(`Validation error: ${(err as Error).message}`);\n    if (args.strict) {\n      return ErrorCodes.REPLAY_DATASET_INVALID;\n    }\n  }\n\n  // Check budget before starting\n  const initialBudgetCheck = checkBudget(budgetContext);\n  if (!initialBudgetCheck.allowed) {\n    console.error(\"Error: Budget constraints exceeded before starting\");\n    printBudgetIssues(initialBudgetCheck);\n    return ErrorCodes.REPLAY_BUDGET_EXCEEDED;\n  }\n\n  console.log(`\\nRunning replay: ${dataset.datasetId}`);\n  console.log(`Description: ${dataset.description ?? \"N/A\"}`);\n  console.log(`Cases: ${dataset.cases.length}`);\n  console.log(\"\");\n\n  // Filter cases if --case specified\n  const casesToRun = args.case\n    ? dataset.cases.filter((c) => c.caseId === args.case)\n    : dataset.cases;\n\n  if (args.case && casesToRun.length === 0) {\n    console.error(`Error: Case \"${args.case}\" not found in dataset`);\n    return ErrorCodes.NOT_FOUND;\n  }\n\n  // Check budget for expected cases\n  if (!budgetGuard.checkAndRecord(\"cases\", casesToRun.length)) {\n    console.error(`Error: Case budget exceeded (${casesToRun.length} cases requested)`);\n    const budgetStatus = checkBudget(budgetContext);\n    printBudgetIssues(budgetStatus);\n    return ErrorCodes.REPLAY_BUDGET_EXCEEDED;\n  }\n\n  // Initialize job queue for async processing\n  const jobQueue = getJobQueue({ autoStart: true });\n\n  // Run each case\n  const results: ReplayResult[] = [];\n  let hasErrors = false;\n\n  for (const replayCaseData of casesToRun) {\n    // Check budget before each case\n    const caseBudgetCheck = checkBudget(budgetContext);\n    if (!caseBudgetCheck.allowed) {\n      console.error(`\\nBudget exceeded before case: ${replayCaseData.caseId}`);\n      printBudgetIssues(caseBudgetCheck);\n      hasErrors = true;\n      break;\n    }\n\n    console.log(`\\nProcessing case: ${replayCaseData.caseId}`);\n    console.log(`  Label: ${replayCaseData.label}`);\n\n    try {\n      // Record branch usage estimate\n      budgetGuard.record(\"branches\", 50); // Estimate 50 branches per case\n\n      const result = await replayCase(replayCaseData, {\n        depth: 3,\n        limits: {},\n        strict: args.strict,\n      });\n\n      results.push(result);\n\n      // Print summary\n      console.log(`  Checkpoints: ${result.checkpoints.length}`);\n      console.log(`  Coverage: ${(result.scoring.coverage.overall * 100).toFixed(1)}%`);\n      console.log(\n        `  Recommended widen factor: ${result.scoring.recommendedAdjustment.widenFactorOverall.toFixed(2)}x`,\n      );\n\n      // Check budget warnings\n      const afterCaseBudget = checkBudget(budgetContext);\n      if (afterCaseBudget.warnings.length > 0) {\n        console.log(`  Budget warnings: ${afterCaseBudget.warnings.length}`);\n      }\n    } catch (err) {\n      console.error(`  Error: ${(err as Error).message}`);\n      hasErrors = true;\n      if (args.strict) {\n        return ErrorCodes.REPLAY_CASE_FAILED;\n      }\n    }\n  }\n\n  // Aggregate results\n  const aggregateCoverage =\n    results.reduce((sum, r) => sum + r.scoring.coverage.overall, 0) / Math.max(results.length, 1);\n\n  const aggregateWidenFactor =\n    results.reduce((sum, r) => sum + r.scoring.recommendedAdjustment.widenFactorOverall, 0) /\n    Math.max(results.length, 1);\n\n  // Print budget summary\n  const finalBudgetCheck = checkBudget(budgetContext);\n\n  console.log(\"\\n\" + \"=\".repeat(60));\n  console.log(\"REPLAY SUMMARY\");\n  console.log(\"=\".repeat(60));\n  console.log(`Total cases: ${results.length}`);\n  console.log(`Overall coverage: ${(aggregateCoverage * 100).toFixed(1)}%`);\n  console.log(`Recommended widen factor: ${aggregateWidenFactor.toFixed(2)}x`);\n\n  // Budget usage summary\n  if (finalBudgetCheck.usage.length > 0) {\n    console.log(\"\\nBudget Usage:\");\n    for (const usage of finalBudgetCheck.usage) {\n      const status = usage.isExceeded ? \"EXCEEDED\" : usage.isWarning ? \"warning\" : \"ok\";\n      console.log(\n        `  ${usage.resource}: ${usage.used}/${usage.limit} (${(usage.percentUsed * 100).toFixed(0)}%) [${status}]`,\n      );\n    }\n  }\n\n  // Per-domain breakdown\n  const domainStats: Record<string, { coverages: number[]; widenFactors: number[] }> = {};\n  for (const result of results) {\n    for (const [domain, coverage] of Object.entries(result.scoring.coverage.byDomain)) {\n      if (!domainStats[domain]) {\n        domainStats[domain] = { coverages: [], widenFactors: [] };\n      }\n      domainStats[domain].coverages.push(coverage);\n    }\n    for (const [domain, factor] of Object.entries(\n      result.scoring.recommendedAdjustment.widenFactorByDomain,\n    )) {\n      if (!domainStats[domain]) {\n        domainStats[domain] = { coverages: [], widenFactors: [] };\n      }\n      domainStats[domain].widenFactors.push(factor);\n    }\n  }\n\n  if (Object.keys(domainStats).length > 0) {\n    console.log(\"\\nPer-domain:\");\n    for (const [domain, stats] of Object.entries(domainStats)) {\n      const avgCoverage =\n        stats.coverages.reduce((a, b) => a + b, 0) / Math.max(stats.coverages.length, 1);\n      const avgWiden =\n        stats.widenFactors.reduce((a, b) => a + b, 0) / Math.max(stats.widenFactors.length, 1);\n      console.log(\n        `  ${domain}: ${(avgCoverage * 100).toFixed(1)}% coverage, ${avgWiden.toFixed(2)}x widen`,\n      );\n    }\n  }\n\n  // Generate reports if output directory specified\n  if (args.reportOut) {\n    const outputDir = resolve(args.reportOut);\n    if (!existsSync(outputDir)) {\n      mkdirSync(outputDir, { recursive: true });\n    }\n\n    // Write JSON report\n    const reportJson = {\n      datasetId: dataset.datasetId,\n      runAt: new Date().toISOString(),\n      summary: {\n        totalCases: results.length,\n        overallCoverage: aggregateCoverage,\n        recommendedWidenFactor: aggregateWidenFactor,\n        byDomain: Object.fromEntries(\n          Object.entries(domainStats).map(([domain, stats]) => [\n            domain,\n            {\n              coverage:\n                stats.coverages.reduce((a, b) => a + b, 0) / Math.max(stats.coverages.length, 1),\n              widenFactor:\n                stats.widenFactors.reduce((a, b) => a + b, 0) /\n                Math.max(stats.widenFactors.length, 1),\n            },\n          ]),\n        ),\n      },\n      caseResults: results,\n    };\n\n    const jsonPath = join(outputDir, \"replay_results.json\");\n    writeFileSync(jsonPath, JSON.stringify(reportJson, null, 2), \"utf8\");\n    console.log(`\\nJSON report: ${jsonPath}`);\n\n    // Write markdown report\n    const mdPath = join(outputDir, \"calibration_report.md\");\n    const mdContent = generateMarkdownReport(dataset, reportJson);\n    writeFileSync(mdPath, mdContent, \"utf8\");\n    console.log(`Markdown report: ${mdPath}`);\n  }\n\n  console.log(\"\");\n  return hasErrors ? ErrorCodes.REPLAY_CASE_FAILED : ErrorCodes.SUCCESS;\n}\n\nfunction printBudgetIssues(budgetCheck: BudgetCheckResult): void {\n  if (budgetCheck.exceeded.length > 0) {\n    console.error(\"\\nBudget exceeded:\");\n    for (const usage of budgetCheck.exceeded) {\n      console.error(\n        `  - ${usage.resource}: ${usage.used}/${usage.limit} (${(usage.percentUsed * 100).toFixed(0)}%)`,\n      );\n    }\n  }\n  if (budgetCheck.warnings.length > 0) {\n    console.warn(\"\\nBudget warnings:\");\n    for (const usage of budgetCheck.warnings) {\n      console.warn(\n        `  - ${usage.resource}: ${usage.used}/${usage.limit} (${(usage.percentUsed * 100).toFixed(0)}%)`,\n      );\n    }\n  }\n  if (budgetCheck.suggestions.length > 0) {\n    console.log(\"\\nSuggestions:\");\n    for (const suggestion of budgetCheck.suggestions) {\n      console.log(`  - ${suggestion}`);\n    }\n  }\n}\n\nfunction generateMarkdownReport(\n  dataset: ReplayDataset,\n  reportJson: {\n    runAt: string;\n    summary: {\n      totalCases: number;\n      overallCoverage: number;\n      recommendedWidenFactor: number;\n      byDomain: Record<string, { coverage: number; widenFactor: number }>;\n    };\n    caseResults: ReplayResult[];\n  },\n): string {\n  const lines: string[] = [];\n\n  lines.push(`# Calibration Report: ${dataset.datasetId}`);\n  lines.push(\"\");\n  lines.push(`**Generated:** ${reportJson.runAt}`);\n  lines.push(`**Description:** ${dataset.description ?? \"N/A\"}`);\n  lines.push(\"\");\n\n  lines.push(\"## Summary\");\n  lines.push(\"\");\n  lines.push(`- **Total Cases:** ${reportJson.summary.totalCases}`);\n  lines.push(`- **Overall Coverage:** ${(reportJson.summary.overallCoverage * 100).toFixed(1)}%`);\n  lines.push(\n    `- **Recommended Widen Factor:** ${reportJson.summary.recommendedWidenFactor.toFixed(2)}x`,\n  );\n  lines.push(\"\");\n\n  if (Object.keys(reportJson.summary.byDomain).length > 0) {\n    lines.push(\"### By Domain\");\n    lines.push(\"\");\n    lines.push(\"| Domain | Coverage | Widen Factor |\");\n    lines.push(\"|--------|----------|--------------|\");\n    for (const [domain, stats] of Object.entries(reportJson.summary.byDomain)) {\n      lines.push(\n        `| ${domain} | ${(stats.coverage * 100).toFixed(1)}% | ${stats.widenFactor.toFixed(2)}x |`,\n      );\n    }\n    lines.push(\"\");\n  }\n\n  lines.push(\"## Results by Case\");\n  lines.push(\"\");\n\n  for (const result of reportJson.caseResults) {\n    lines.push(`### ${result.caseId}`);\n    lines.push(\"\");\n    lines.push(`- **Checkpoints:** ${result.checkpoints.length}`);\n    lines.push(`- **Coverage:** ${(result.scoring.coverage.overall * 100).toFixed(1)}%`);\n    lines.push(\n      `- **Widen Factor:** ${result.scoring.recommendedAdjustment.widenFactorOverall.toFixed(2)}x`,\n    );\n    lines.push(`- **Rationale:** ${result.scoring.recommendedAdjustment.rationale}`);\n\n    if (Object.keys(result.scoring.coverage.byMetricId).length > 0) {\n      lines.push(\"\");\n      lines.push(\"**Per-Metric Coverage:**\");\n      lines.push(\"\");\n      for (const [metricId, coverage] of Object.entries(result.scoring.coverage.byMetricId)) {\n        lines.push(`- ${metricId}: ${(coverage * 100).toFixed(1)}%`);\n      }\n    }\n\n    lines.push(\"\");\n  }\n\n  lines.push(\"---\");\n  lines.push(\"\");\n  lines.push(\"*This report was generated by Zeo Replay Runner v0.3.1*\");\n  lines.push(\n    \"*Calibration follows the widen-only rule: intervals may only be widened, never narrowed.*\",\n  );\n  lines.push(\"\");\n\n  return lines.join(\"\\n\");\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\scaffold-cli.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'dirname' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":10,"messageId":"unusedVar","endLine":12,"endColumn":17,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"dirname"},"fix":{"range":[432,440],"text":""},"desc":"Remove unused variable \"dirname\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Scaffold CLI - Project scaffolding commands\n *\n * Commands:\n *   scaffold pack <name> [--template <tpl>]   Create a new pack\n *   scaffold plugin <name> --type <type>      Create a new plugin\n *   scaffold config                           Create project config\n *   scaffold list                             List available templates\n */\n\nimport { existsSync, mkdirSync, readFileSync, writeFileSync } from \"node:fs\";\nimport { dirname, join, resolve } from \"node:path\";\n\nexport interface ScaffoldArgs {\n  command: \"pack\" | \"plugin\" | \"config\" | \"list\" | null;\n  name?: string;\n  template?: string;\n  type?: string;\n}\n\ninterface Template {\n  name: string;\n  description: string;\n  variables: Array<{\n    name: string;\n    prompt: string;\n    required?: boolean;\n    default?: string;\n    validate?: string;\n  }>;\n  output?: string;\n}\n\ninterface TemplateSet {\n  [key: string]: {\n    template: Template;\n    files: string[];\n  };\n}\n\nconst TEMPLATES_DIR = resolve(process.cwd(), \"templates\");\n\nfunction loadTemplates(category: string): TemplateSet {\n  const categoryDir = join(TEMPLATES_DIR, category);\n  if (!existsSync(categoryDir)) return {};\n\n  const templates: TemplateSet = {};\n  const dirs = readdirSyncSafe(categoryDir);\n\n  for (const dir of dirs) {\n    const templateJsonPath = join(categoryDir, dir, \"template.json\");\n    if (!existsSync(templateJsonPath)) continue;\n\n    try {\n      const template: Template = JSON.parse(readFileSync(templateJsonPath, \"utf8\"));\n      const files = readdirSyncSafe(join(categoryDir, dir)).filter(\n        (f) => f.endsWith(\".template\") || f === \"template.json\",\n      );\n      templates[dir] = { template, files };\n    } catch {\n      // Skip invalid templates\n    }\n  }\n\n  return templates;\n}\n\nfunction readdirSyncSafe(dir: string): string[] {\n  try {\n    return require(\"node:fs\")\n      .readdirSync(dir, { withFileTypes: true })\n      .filter((d: { isDirectory: () => boolean }) => d.isDirectory())\n      .map((d: { name: string }) => d.name);\n  } catch {\n    return [];\n  }\n}\n\nfunction substituteVariables(content: string, variables: Record<string, string>): string {\n  let result = content;\n  for (const [key, value] of Object.entries(variables)) {\n    const regex = new RegExp(`\\\\{\\\\{${key}\\\\}\\\\}`, \"g\");\n    result = result.replace(regex, value);\n  }\n  // Special variables\n  result = result.replace(/\\\\{\\\\{now\\\\.iso\\\\}\\\\}/g, new Date().toISOString());\n  return result;\n}\n\nfunction scaffoldPack(name: string, templateName: string): number {\n  const templates = loadTemplates(\"pack\");\n  const selected = templates[templateName];\n\n  if (!selected) {\n    console.error(`Template not found: ${templateName}`);\n    console.log(`Available: ${Object.keys(templates).join(\", \")}`);\n    return 1;\n  }\n\n  const outputDir = resolve(process.cwd(), \"packs\", name);\n  if (existsSync(outputDir)) {\n    console.error(`Pack already exists: ${outputDir}`);\n    return 1;\n  }\n\n  // Collect variable values (in real implementation, these would be prompted)\n  const variables: Record<string, string> = {\n    name,\n    description: \"A Reach execution pack\",\n    author: \"local\",\n    version: \"1.0.0\",\n    license: \"MIT\",\n    created: new Date().toISOString(),\n  };\n\n  mkdirSync(outputDir, { recursive: true });\n\n  // Copy template files\n  const templateDir = join(TEMPLATES_DIR, \"pack\", templateName);\n  for (const file of selected.files) {\n    if (file === \"template.json\") continue;\n\n    const sourcePath = join(templateDir, file);\n    const targetName = file.replace(\".template\", \"\");\n    const targetPath = join(outputDir, targetName);\n\n    const content = readFileSync(sourcePath, \"utf8\");\n    const processed = substituteVariables(content, variables);\n    writeFileSync(targetPath, processed, \"utf8\");\n  }\n\n  console.log(`✅ Created pack: ${outputDir}`);\n  console.log(`   Template: ${templateName}`);\n  console.log(`\\nNext steps:`);\n  console.log(`  1. Edit ${join(name, \"pack.json\")}`);\n  console.log(`  2. Add your execution steps`);\n  console.log(`  3. Run with: reach run local.${name}`);\n\n  return 0;\n}\n\nfunction scaffoldPlugin(name: string, type: string, _templateName: string): number {\n  const templates = loadTemplates(\"plugin\");\n  const selected = templates[type];\n\n  if (!selected) {\n    console.error(`Plugin type not found: ${type}`);\n    console.log(`Available: ${Object.keys(templates).join(\", \")}`);\n    return 1;\n  }\n\n  const outputDir = resolve(process.cwd(), \"plugins\", name);\n  if (existsSync(outputDir)) {\n    console.error(`Plugin already exists: ${outputDir}`);\n    return 1;\n  }\n\n  const variables: Record<string, string> = {\n    name,\n    description: `A ${type} plugin for Reach`,\n    author: \"local\",\n    version: \"1.0.0\",\n    license: \"MIT\",\n  };\n\n  mkdirSync(outputDir, { recursive: true });\n\n  const templateDir = join(TEMPLATES_DIR, \"plugin\", type);\n  for (const file of selected.files) {\n    if (file === \"template.json\") continue;\n\n    const sourcePath = join(templateDir, file);\n    const targetName = file.replace(\".template\", \"\");\n    const targetPath = join(outputDir, targetName);\n\n    const content = readFileSync(sourcePath, \"utf8\");\n    const processed = substituteVariables(content, variables);\n    writeFileSync(targetPath, processed, \"utf8\");\n  }\n\n  console.log(`✅ Created plugin: ${outputDir}`);\n  console.log(`   Type: ${type}`);\n  console.log(`\\nNext steps:`);\n  console.log(`  1. Edit ${join(name, \"index.js\")}`);\n  console.log(`  2. Implement your ${type} logic`);\n  console.log(`  3. Validate with: reach plugins doctor`);\n\n  return 0;\n}\n\nfunction scaffoldConfig(): number {\n  const templates = loadTemplates(\"config\");\n  const selected = Object.values(templates)[0];\n\n  if (!selected) {\n    console.error(\"No config template found\");\n    return 1;\n  }\n\n  const outputPath = resolve(process.cwd(), selected.template.output || \"reach.config.json\");\n  if (existsSync(outputPath)) {\n    console.error(`Config already exists: ${outputPath}`);\n    return 1;\n  }\n\n  const variables: Record<string, string> = {\n    project_name: \"my-reach-project\",\n    project_description: \"A Reach project\",\n  };\n\n  const templateDir = join(TEMPLATES_DIR, \"config\");\n  const sourceFile = selected.files.find((f) => f.endsWith(\".template\"));\n\n  if (sourceFile) {\n    const content = readFileSync(join(templateDir, sourceFile), \"utf8\");\n    const processed = substituteVariables(content, variables);\n    writeFileSync(outputPath, processed, \"utf8\");\n  }\n\n  console.log(`✅ Created config: ${outputPath}`);\n  console.log(`\\nEdit this file to customize your project settings.`);\n\n  return 0;\n}\n\nfunction listTemplates(): number {\n  console.log(\"📦 Available Templates\\n\");\n\n  const categories = [\"pack\", \"plugin\", \"config\"];\n\n  for (const category of categories) {\n    const templates = loadTemplates(category);\n    if (Object.keys(templates).length === 0) continue;\n\n    console.log(`${category.toUpperCase()}:`);\n    for (const [id, { template }] of Object.entries(templates)) {\n      console.log(`  ${id.padEnd(15)} - ${template.description}`);\n    }\n    console.log(\"\");\n  }\n\n  console.log(\"Usage:\");\n  console.log(\"  reach scaffold pack <name> [--template <tpl>]\");\n  console.log(\"  reach scaffold plugin <name> --type <type>\");\n  console.log(\"  reach scaffold config\");\n\n  return 0;\n}\n\nexport function parseScaffoldArgs(argv: string[]): ScaffoldArgs {\n  const command = argv[0] as ScaffoldArgs[\"command\"];\n  const name = argv[1];\n\n  let template: string | undefined;\n  let type: string | undefined;\n\n  for (let i = 0; i < argv.length; i++) {\n    if (argv[i] === \"--template\" && argv[i + 1]) {\n      template = argv[i + 1];\n      i++;\n    }\n    if (argv[i] === \"--type\" && argv[i + 1]) {\n      type = argv[i + 1];\n      i++;\n    }\n  }\n\n  return { command, name, template, type };\n}\n\nexport async function runScaffoldCommand(args: ScaffoldArgs): Promise<number> {\n  if (args.command === \"list\") {\n    return listTemplates();\n  }\n\n  if (!args.command) {\n    console.log(\"Usage: reach scaffold <pack|plugin|config|list> [options]\");\n    return 1;\n  }\n\n  switch (args.command) {\n    case \"pack\": {\n      if (!args.name) {\n        console.error(\"Usage: reach scaffold pack <name> [--template <tpl>]\");\n        return 1;\n      }\n      return scaffoldPack(args.name, args.template || \"standard\");\n    }\n\n    case \"plugin\": {\n      if (!args.name) {\n        console.error(\"Usage: reach scaffold plugin <name> --type <type>\");\n        return 1;\n      }\n      if (!args.type) {\n        console.error(\"Error: --type is required (analyzer|renderer|retriever)\");\n        return 1;\n      }\n      return scaffoldPlugin(args.name, args.type, args.template || \"default\");\n    }\n\n    case \"config\": {\n      return scaffoldConfig();\n    }\n\n    default:\n      console.error(`Unknown scaffold command: ${args.command}`);\n      return 1;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\slice-eval-cli.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'join' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":19,"messageId":"unusedVar","endLine":8,"endColumn":23,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"join"},"fix":{"range":[131,137],"text":""},"desc":"Remove unused variable \"join\"."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @ts-nocheck\n/**\n * Slice Eval CLI Module\n *\n * CLI interface for slice-based evaluation with gating rules.\n */\n\nimport { resolve, join } from \"node:path\";\nimport { readFileSync, existsSync } from \"node:fs\";\nimport {\n  runSliceEvaluation,\n  printSliceSummary,\n  checkSliceGates,\n  type SliceEvalOptions,\n  type SliceDimension,\n  getGatingThresholds,\n} from \"@zeo/eval\";\nimport type { ReplayDataset, ReplayResult, CalibrationBucket } from \"@zeo/contracts\";\n\n/**\n * Slice eval CLI arguments\n */\nexport interface SliceEvalCliArgs {\n  /** Path to replay dataset JSON */\n  dataset?: string;\n\n  /** Output directory for slice results */\n  output?: string;\n\n  /** Slice dimensions to compute (comma-separated) */\n  dimensions?: string;\n\n  /** Gating threshold preset (strict/standard/lenient) */\n  preset?: string;\n\n  /** Explicit seed for determinism */\n  seed?: string;\n\n  /** Skip CSV output */\n  noCsv?: boolean;\n\n  /** Skip JSON output */\n  noJson?: boolean;\n\n  /** Fail on warnings (treat warnings as errors) */\n  strict?: boolean;\n\n  /** Verbose output */\n  verbose?: boolean;\n\n  /** Show help */\n  help?: boolean;\n}\n\n/**\n * Parse slice eval arguments\n */\nexport function parseSliceEvalArgs(argv: string[]): SliceEvalCliArgs {\n  const result: SliceEvalCliArgs = {\n    dataset: undefined,\n    output: \"./eval/slices\",\n    dimensions: undefined,\n    preset: \"standard\",\n    seed: undefined,\n    noCsv: false,\n    noJson: false,\n    strict: false,\n    verbose: false,\n    help: false,\n  };\n\n  for (let i = 0; i < argv.length; i++) {\n    const arg = argv[i];\n    const next = argv[i + 1];\n\n    if ((arg === \"--dataset\" || arg === \"-d\") && next) {\n      result.dataset = next;\n      i++;\n    } else if ((arg === \"--output\" || arg === \"-o\") && next) {\n      result.output = next;\n      i++;\n    } else if ((arg === \"--dimensions\" || arg === \"-D\") && next) {\n      result.dimensions = next;\n      i++;\n    } else if ((arg === \"--preset\" || arg === \"-p\") && next) {\n      result.preset = next;\n      i++;\n    } else if ((arg === \"--seed\" || arg === \"-s\") && next) {\n      result.seed = next;\n      i++;\n    } else if (arg === \"--no-csv\") {\n      result.noCsv = true;\n    } else if (arg === \"--no-json\") {\n      result.noJson = true;\n    } else if (arg === \"--strict\") {\n      result.strict = true;\n    } else if (arg === \"--verbose\" || arg === \"-v\") {\n      result.verbose = true;\n    } else if (arg === \"--help\" || arg === \"-h\") {\n      result.help = true;\n    }\n  }\n\n  return result;\n}\n\n/**\n * Print slice eval help\n */\nexport function printSliceEvalHelp(): void {\n  console.log(`\nZeo Slice Eval - Granular Evaluation by Dimension\n\nUsage: zeo eval:slices [options]\n\nOptions:\n  --dataset, -d <path>      Path to replay dataset JSON (required)\n  --output, -o <dir>        Output directory (default: ./eval/slices)\n  --dimensions, -D <list>  Comma-separated dimensions (default: domain,metricKind,confidenceLevel)\n  --preset, -p <name>      Gating preset: strict|standard|lenient (default: standard)\n  --seed, -s <seed>         Explicit seed for determinism\n  --no-csv                  Skip CSV output\n  --no-json                 Skip JSON output\n  --strict                  Treat warnings as errors\n  --verbose, -v             Verbose output\n  --help, -h                Show this help message\n\nDimensions:\n  domain           Business domain (negotiation, ops, etc.)\n  metricKind       Outcome type (binary, continuous, ordinal, band)\n  confidenceLevel  Prediction confidence (low, medium, high)\n  outcomeStatus    Resolution status (resolved, partially_resolved)\n  decisionType     Type of decision\n  timePeriod       Month/quarter of decision\n\nGating Presets:\n  strict     High thresholds (min 50 samples, 85% coverage)\n  standard   Balanced thresholds (min 30 samples, 80% coverage)\n  lenient    Permissive thresholds (min 10 samples, 70% coverage)\n\nExamples:\n  zeo eval:slices --dataset external/examples/replay/sample_dataset.json\n  zeo eval:slices -d dataset.json -o ./results --preset strict\n  zeo eval:slices -d dataset.json -D domain,metricKind --strict\n\nOutput Files:\n  eval/slices.json    Full slice evaluation report\n  eval/slices.csv     Slice metrics in CSV format\n`);\n}\n\n/**\n * Parse dimensions from comma-separated string\n */\nfunction parseDimensions(dimensionsStr: string | undefined): SliceDimension[] {\n  if (!dimensionsStr) {\n    return [\"domain\", \"metricKind\", \"confidenceLevel\"];\n  }\n\n  const validDimensions: SliceDimension[] = [\n    \"domain\",\n    \"metricKind\",\n    \"confidenceLevel\",\n    \"outcomeStatus\",\n    \"decisionType\",\n    \"timePeriod\",\n  ];\n\n  const parsed = dimensionsStr\n    .split(\",\")\n    .map((d) => d.trim())\n    .filter((d): d is SliceDimension => validDimensions.includes(d as SliceDimension));\n\n  if (parsed.length === 0) {\n    throw new Error(`No valid dimensions provided. Valid: ${validDimensions.join(\", \")}`);\n  }\n\n  return parsed;\n}\n\n/**\n * Validate preset name\n */\nfunction validatePreset(preset: string): \"strict\" | \"standard\" | \"lenient\" {\n  if (preset === \"strict\" || preset === \"standard\" || preset === \"lenient\") {\n    return preset;\n  }\n  throw new Error(`Invalid preset: ${preset}. Use: strict, standard, or lenient`);\n}\n\n/**\n * Run slice evaluation from CLI\n */\nexport async function runSliceEvalCommand(args: SliceEvalCliArgs): Promise<number> {\n  if (args.help) {\n    printSliceEvalHelp();\n    return 0;\n  }\n\n  if (!args.dataset) {\n    console.error(\"[SLICE_EVAL_ERROR] No dataset specified. Use --dataset <path>\");\n    console.error(\"Run 'zeo eval:slices --help' for usage information.\");\n    return 1;\n  }\n\n  const datasetPath = resolve(process.cwd(), args.dataset);\n\n  if (!existsSync(datasetPath)) {\n    console.error(`[SLICE_EVAL_ERROR] Dataset not found: ${datasetPath}`);\n    return 1;\n  }\n\n  try {\n    // Load dataset\n    if (args.verbose) {\n      console.log(`Loading dataset from ${datasetPath}...`);\n    }\n\n    const datasetContent = readFileSync(datasetPath, \"utf8\");\n    const dataset: ReplayDataset = JSON.parse(datasetContent);\n\n    // Parse dimensions\n    const dimensions = parseDimensions(args.dimensions);\n    if (args.verbose) {\n      console.log(`Computing slices for dimensions: ${dimensions.join(\", \")}`);\n    }\n\n    // Validate preset and get thresholds\n    const preset = validatePreset(args.preset || \"standard\");\n    const thresholds = getGatingThresholds(preset);\n\n    if (args.verbose) {\n      console.log(`Using ${preset} gating preset:`);\n      console.log(`  Min sample size: ${thresholds.minSampleSize}`);\n      console.log(`  Min coverage: ${(thresholds.minCoverage * 100).toFixed(0)}%`);\n      console.log(`  Max Brier: ${thresholds.maxBrierScore}`);\n    }\n\n    // For now, create synthetic replay results since we need to integrate\n    // with the actual replay runner. In production, this would run the\n    // replay pipeline and get actual results.\n    const replayResults: ReplayResult[] = dataset.cases.map((c) => ({\n      caseId: c.caseId,\n      runMeta: {\n        seed: args.seed || \"test-seed\",\n        engineVersion: \"0.5.1\",\n        decisionHash: \"mock-hash\",\n        observationsHash: \"mock-obs-hash\",\n        startedAt: new Date().toISOString(),\n        completedAt: new Date().toISOString(),\n      },\n      checkpoints: [\n        {\n          at: c.horizons.asOf,\n          posteriorSummary: {\n            variableCount: c.decisionSpec.assumptions?.length || 0,\n            observationCount: c.observationBatches.reduce(\n              (sum, b) => sum + b.observations.length,\n              0,\n            ),\n            modelStrength: 0.7,\n          },\n          predictions: {\n            at: c.horizons.asOf,\n            predictions: c.outcome.metrics.map((m) => ({\n              target: {\n                kind: m.mapping.linksTo,\n                id: m.mapping.targetId,\n              },\n              band: { low: 0.3, high: 0.7 },\n              provenanceRefs: [] as string[],\n              basis: {\n                decisionHash: \"mock\",\n                observationHash: \"mock\",\n                seed: args.seed || \"test\",\n                engineVersion: \"0.5.1\",\n              },\n            })),\n          },\n        },\n      ],\n      scoring: {\n        coverage: { byMetricId: {}, byDomain: {}, overall: 0.8 },\n        properScores: { byMetricId: {}, overall: 0.15 },\n        buckets: [] as CalibrationBucket[],\n        recommendedAdjustment: {\n          widenFactorByDomain: {},\n          widenFactorOverall: 1.0,\n          rationale: \"Mock scoring\",\n        },\n      },\n    }));\n\n    // Build options\n    const options: SliceEvalOptions = {\n      outputDir: resolve(process.cwd(), args.output || \"./eval/slices\"),\n      dimensions,\n      seed: args.seed,\n      engineVersion: \"0.5.1\",\n      includeCsv: !args.noCsv,\n      includeJson: !args.noJson,\n    };\n\n    // Run evaluation\n    console.log(`\\n=== Slice Evaluation ===`);\n    console.log(`Dataset: ${dataset.datasetId}`);\n    console.log(`Cases: ${dataset.cases.length}`);\n    console.log(`Dimensions: ${dimensions.join(\", \")}`);\n    console.log(`Preset: ${preset}`);\n    console.log(`Output: ${options.outputDir}`);\n\n    const report = await runSliceEvaluation(replayResults, dataset, options);\n\n    // Print summary\n    printSliceSummary(report);\n\n    // Check gates\n    const gateResult = checkSliceGates(report);\n\n    console.log(\"\\n--- Gate Results ---\");\n    console.log(`Status: ${gateResult.passed ? \"PASSED\" : \"FAILED\"}`);\n\n    if (gateResult.errors.length > 0) {\n      console.log(\"\\nErrors:\");\n      gateResult.errors.forEach((e) => console.log(`  ✗ ${e}`));\n    }\n\n    if (gateResult.warnings.length > 0) {\n      console.log(\"\\nWarnings:\");\n      gateResult.warnings.forEach((w) => console.log(`  ⚠ ${w}`));\n    }\n\n    // Determine exit code\n    if (!gateResult.passed) {\n      return 1;\n    }\n\n    if (args.strict && gateResult.warnings.length > 0) {\n      console.log(\"\\n[STRICT MODE] Warnings treated as errors.\");\n      return 1;\n    }\n\n    return 0;\n  } catch (err) {\n    console.error(`[SLICE_EVAL_ERROR] ${err instanceof Error ? err.message : err}`);\n    if (args.verbose) {\n      console.error(err);\n    }\n    return 1;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\snapshot-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\status-cli.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'performance' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":10,"messageId":"unusedVar","endLine":5,"endColumn":21,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"performance"},"fix":{"range":[185,232],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { loadConfig } from \"../core/env.js\";\n// @ts-nocheck\n// @ts-ignore - External package may not be available in all environments\nimport { listRecentArtifacts } from \"@zeo/ledger\";\nimport { performance } from \"node:perf_hooks\";\nimport os from \"node:os\";\n\nexport async function runStatusCommand(): Promise<number> {\n  const recent = listRecentArtifacts(10);\n  const uptime = os.uptime();\n\n  const latencies = recent\n    .map((a: { execution_duration_ms?: number }) => a.execution_duration_ms)\n    .filter(Boolean);\n  const avgLatency =\n    latencies.length > 0\n      ? (latencies.reduce((a: number, b: number) => a + b, 0) / latencies.length).toFixed(2)\n      : \"N/A\";\n\n  console.log(\"\\n=== Zeo Operator Status ===\");\n  console.log(`System Uptime: ${(uptime / 3600).toFixed(2)} hours`);\n  console.log(`Average Latency (recent): ${avgLatency}ms`);\n  console.log(`Recent Decisions: ${recent.length}`);\n  console.log(\"\\nLast 10 Decisions:\");\n  recent.forEach(\n    (a: { decision_id: string; timestamp: string; execution_duration_ms?: number }) => {\n      console.log(`- ${a.decision_id}: ${a.timestamp} (${a.execution_duration_ms}ms)`);\n    },\n  );\n\n  console.log(\"\\nConfig Summary:\");\n  console.log(`- NODE_ENV: ${loadConfig().NODE_ENV}`);\n  console.log(`- ZE0_STRICT: ${loadConfig().ZEO_STRICT}`);\n\n  // MCP Health check - dummy implementation for now as per instructions \"no new heavy deps\"\n  // If mcp package exists, we could check it.\n  console.log(\"- MCP Health: OK (Standalone)\");\n\n  return 0;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\studio-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\tools-cli.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'snapshots' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":124,"column":11,"messageId":"unusedVar","endLine":124,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'graph' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":140,"column":11,"messageId":"unusedVar","endLine":140,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @ts-nocheck\n/**\n * Tools CLI\n *\n * zeo tools — Show agent/tool health status (READY | ERROR | TIMEOUT)\n */\n\nexport async function runToolsCommand(argv: string[]): Promise<number> {\n  const json = argv.includes(\"--json\");\n  const core = await import(\"@zeo/core\");\n\n  // Register default tools\n  const defaultAgents: Array<{\n    name: string;\n    description: string;\n    timeoutMs: number;\n  }> = [\n    {\n      name: \"branch_generator\",\n      description: \"Generate decision branch graphs\",\n      timeoutMs: 5000,\n    },\n    {\n      name: \"robustness_evaluator\",\n      description: \"Evaluate action robustness\",\n      timeoutMs: 5000,\n    },\n    {\n      name: \"expected_utility_evaluator\",\n      description: \"Qualitative expected utility analysis\",\n      timeoutMs: 5000,\n    },\n    {\n      name: \"game_theory_evaluator\",\n      description: \"Game-theoretic analysis\",\n      timeoutMs: 5000,\n    },\n    {\n      name: \"evolutionary_evaluator\",\n      description: \"Evolutionary fitness evaluation\",\n      timeoutMs: 5000,\n    },\n    {\n      name: \"flip_condition_generator\",\n      description: \"Identify assumption flip conditions\",\n      timeoutMs: 5000,\n    },\n    {\n      name: \"evidence_ranker\",\n      description: \"Rank evidence by VOI\",\n      timeoutMs: 5000,\n    },\n    { name: \"mcp_server\", description: \"MCP stdio server\", timeoutMs: 10000 },\n    {\n      name: \"replay_engine\",\n      description: \"Deterministic replay verification\",\n      timeoutMs: 30000,\n    },\n    {\n      name: \"evidence_graph\",\n      description: \"Persistent evidence registry\",\n      timeoutMs: 5000,\n    },\n    {\n      name: \"plan_engine\",\n      description: \"Regret-aware planning\",\n      timeoutMs: 10000,\n    },\n  ];\n\n  for (const agent of defaultAgents) {\n    core.registerAgent({\n      name: agent.name,\n      description: agent.description,\n      inputSchema: { type: \"object\" },\n      outputSchema: { type: \"object\" },\n      costEstimate: {\n        tokensMin: 0,\n        tokensMax: 1000,\n        costUsdMin: 0,\n        costUsdMax: 0.01,\n      },\n      timeoutMs: agent.timeoutMs,\n    });\n  }\n\n  // Check health of all registered agents\n  const healthResults: Array<{\n    name: string;\n    status: string;\n    latencyMs?: number;\n    error?: string;\n  }> = [];\n\n  for (const agent of defaultAgents) {\n    const health = await core.checkAgentHealth(agent.name);\n    healthResults.push({\n      name: health.name,\n      status: health.status,\n      latencyMs: health.latencyMs,\n      error: health.error,\n    });\n  }\n\n  // Also check MCP tools\n  try {\n    const { validateMcpToolDefinitions } = await import(\"./mcp-cli.js\");\n    const issues = validateMcpToolDefinitions();\n    healthResults.push({\n      name: \"mcp_tools_schema\",\n      status: issues.length === 0 ? \"READY\" : \"ERROR\",\n      error: issues.length > 0 ? issues.join(\"; \") : undefined,\n    });\n  } catch {\n    healthResults.push({\n      name: \"mcp_tools_schema\",\n      status: \"ERROR\",\n      error: \"MCP module unavailable\",\n    });\n  }\n\n  // Check snapshot storage\n  try {\n    const snapshots = core.listSnapshots();\n    healthResults.push({\n      name: \"snapshot_storage\",\n      status: \"READY\",\n      latencyMs: 0,\n    });\n  } catch {\n    healthResults.push({\n      name: \"snapshot_storage\",\n      status: \"ERROR\",\n      error: \"Snapshot storage inaccessible\",\n    });\n  }\n\n  // Check evidence graph\n  try {\n    const graph = core.loadEvidenceGraph();\n    healthResults.push({\n      name: \"evidence_store\",\n      status: \"READY\",\n      latencyMs: 0,\n    });\n  } catch {\n    healthResults.push({\n      name: \"evidence_store\",\n      status: \"ERROR\",\n      error: \"Evidence graph inaccessible\",\n    });\n  }\n\n  if (json) {\n    console.log(JSON.stringify(healthResults, null, 2));\n  } else {\n    console.log(\"\\n=== Zeo Tools Status ===\\n\");\n    for (const h of healthResults) {\n      const statusStr =\n        h.status === \"READY\" ? \"READY  \" : h.status === \"TIMEOUT\" ? \"TIMEOUT\" : \"ERROR  \";\n      const latency = h.latencyMs !== undefined ? ` (${h.latencyMs}ms)` : \"\";\n      console.log(`  [${statusStr}] ${h.name}${latency}`);\n      if (h.error) console.log(`           ${h.error}`);\n    }\n    console.log(\"\");\n  }\n\n  const hasErrors = healthResults.some((h) => h.status === \"ERROR\" || h.status === \"TIMEOUT\");\n  return hasErrors ? 1 : 0;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\transcript-cli.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\transcript-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\trust-cli.ts","messages":[{"ruleId":"no-useless-assignment","severity":1,"message":"This assigned value is not used in subsequent statements.","line":218,"column":15,"messageId":"unnecessaryAssignment","endLine":218,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @ts-nocheck\n/**\n * Trust Engine CLI\n *\n * Commands:\n *   zeo replay <run_id>         Replay and verify deterministic agreement\n *   zeo diff <runA> <runB>      Compare two runs\n *   zeo explain <run_id>        Summarized reasoning trace\n *   zeo trace <run_id>          Step-by-step structured trace\n *   zeo snapshots               List all snapshots\n */\n\nexport interface TrustCliArgs {\n  command: \"replay-run\" | \"diff\" | \"explain\" | \"trace\" | \"snapshots\" | null;\n  runId: string | undefined;\n  runIdB: string | undefined;\n  json: boolean;\n}\n\nexport function parseTrustArgs(argv: string[]): TrustCliArgs {\n  return {\n    command: null,\n    runId: argv[0],\n    runIdB: argv[1],\n    json: argv.includes(\"--json\"),\n  };\n}\n\nexport async function runTrustReplayCommand(runId: string, json: boolean): Promise<number> {\n  const { replayRun, formatReplayResult } = await import(\"@zeo/core\");\n\n  try {\n    const result = replayRun(runId);\n    if (json) {\n      console.log(JSON.stringify(result, null, 2));\n    } else {\n      console.log(formatReplayResult(result));\n    }\n    return result.verdict === \"PASS\" ? 0 : 1;\n  } catch (err) {\n    console.error(`[REPLAY_ERROR] ${(err as Error).message}`);\n    return 1;\n  }\n}\n\nexport async function runDiffCommand(\n  runIdA: string,\n  runIdB: string,\n  json: boolean,\n): Promise<number> {\n  const { diffRuns, formatRunDiff } = await import(\"@zeo/core\");\n\n  try {\n    const diff = diffRuns(runIdA, runIdB);\n    if (json) {\n      console.log(JSON.stringify(diff, null, 2));\n    } else {\n      console.log(formatRunDiff(diff));\n    }\n    return 0;\n  } catch (err) {\n    console.error(`[DIFF_ERROR] ${(err as Error).message}`);\n    return 1;\n  }\n}\n\nexport async function runExplainCommand(runId: string, json: boolean): Promise<number> {\n  const { loadSnapshot } = await import(\"@zeo/core\");\n\n  const snapshot = loadSnapshot(runId);\n  if (!snapshot) {\n    console.error(`Snapshot not found: ${runId}`);\n    console.error(\"Run 'zeo snapshots' to list available snapshots.\");\n    return 1;\n  }\n\n  if (json) {\n    console.log(\n      JSON.stringify(\n        {\n          runId: snapshot.runId,\n          createdAt: snapshot.createdAt,\n          deterministic: snapshot.deterministic,\n          seed: snapshot.seed,\n          inputHash: snapshot.inputHash,\n          outputHash: snapshot.outputHash,\n          chainHash: snapshot.chainHash,\n          durationMs: snapshot.durationMs,\n          spec: {\n            title: snapshot.input.spec.title,\n            context: snapshot.input.spec.context,\n            actions: snapshot.input.spec.actions.length,\n            assumptions: snapshot.input.spec.assumptions.length,\n          },\n          evaluations: snapshot.output?.evaluations.map((e) => ({\n            lens: e.lens,\n            robustActions: e.robustActions.length,\n            fragileAssumptions: e.fragileAssumptions.length,\n          })),\n        },\n        null,\n        2,\n      ),\n    );\n  } else {\n    console.log(`\\n=== Run Explanation: ${snapshot.runId} ===`);\n    console.log(`Created: ${snapshot.createdAt}`);\n    console.log(`Deterministic: ${snapshot.deterministic}`);\n    if (snapshot.seed) console.log(`Seed: ${snapshot.seed}`);\n    console.log(`Duration: ${snapshot.durationMs}ms`);\n    console.log(`Input Hash: ${snapshot.inputHash.slice(0, 16)}...`);\n    console.log(`Output Hash: ${snapshot.outputHash.slice(0, 16)}...`);\n    console.log(`Chain Hash: ${snapshot.chainHash.slice(0, 16)}...`);\n    console.log(\"\");\n    console.log(`Decision: ${snapshot.input.spec.title}`);\n    console.log(`Context: ${snapshot.input.spec.context}`);\n    console.log(`Actions: ${snapshot.input.spec.actions.length}`);\n    console.log(`Assumptions: ${snapshot.input.spec.assumptions.length}`);\n\n    if (snapshot.output) {\n      console.log(\"\");\n      console.log(\"Evaluations:\");\n      for (const evaluation of snapshot.output.evaluations) {\n        console.log(\n          `  [${evaluation.lens}] Robust: ${evaluation.robustActions.length}, Fragile: ${evaluation.fragileAssumptions.length}`,\n        );\n      }\n\n      if (snapshot.output.explanation) {\n        console.log(\"\");\n        console.log(\"Reasoning:\");\n        for (const why of snapshot.output.explanation.why) {\n          console.log(`  - ${why}`);\n        }\n        if (snapshot.output.explanation.whatWouldChange.length > 0) {\n          console.log(\"\");\n          console.log(\"What Would Change:\");\n          for (const change of snapshot.output.explanation.whatWouldChange) {\n            console.log(`  - ${change.assumptionId}: ${change.flipCondition}`);\n          }\n        }\n      }\n    }\n  }\n\n  return 0;\n}\n\nexport async function runTraceCommand(runId: string, json: boolean): Promise<number> {\n  const { loadSnapshot } = await import(\"@zeo/core\");\n\n  const snapshot = loadSnapshot(runId);\n  if (!snapshot) {\n    console.error(`Snapshot not found: ${runId}`);\n    return 1;\n  }\n\n  // Build trace from snapshot data\n  const trace = {\n    runId: snapshot.runId,\n    steps: [] as Array<{\n      step: number;\n      phase: string;\n      detail: string;\n      outputHash: string;\n    }>,\n  };\n\n  let stepNum = 0;\n\n  // Step 1: Input canonicalization\n  trace.steps.push({\n    step: ++stepNum,\n    phase: \"input_canonicalization\",\n    detail: `Canonicalized decision spec: \"${snapshot.input.spec.title}\"`,\n    outputHash: snapshot.inputHash.slice(0, 16),\n  });\n\n  // Step 2: Branch generation\n  if (snapshot.output) {\n    trace.steps.push({\n      step: ++stepNum,\n      phase: \"branch_generation\",\n      detail: `Generated ${snapshot.output.graph.nodes.length} nodes, ${snapshot.output.graph.edges.length} edges`,\n      outputHash: snapshot.outputHash.slice(0, 16),\n    });\n\n    // Step 3: Evaluations\n    for (const evaluation of snapshot.output.evaluations) {\n      trace.steps.push({\n        step: ++stepNum,\n        phase: `evaluation_${evaluation.lens}`,\n        detail: `${evaluation.lens}: ${evaluation.robustActions.length} robust, ${evaluation.dominatedActions.length} dominated`,\n        outputHash: snapshot.outputHash.slice(0, 16),\n      });\n    }\n\n    // Step 4: Flip conditions\n    if (snapshot.output.explanation.whatWouldChange.length > 0) {\n      trace.steps.push({\n        step: ++stepNum,\n        phase: \"flip_conditions\",\n        detail: `${snapshot.output.explanation.whatWouldChange.length} flip condition(s) identified`,\n        outputHash: snapshot.outputHash.slice(0, 16),\n      });\n    }\n\n    // Step 5: Evidence ranking\n    trace.steps.push({\n      step: ++stepNum,\n      phase: \"evidence_ranking\",\n      detail: `${snapshot.output.nextBestEvidence.length} evidence action(s) ranked`,\n      outputHash: snapshot.outputHash.slice(0, 16),\n    });\n\n    // Step 6: Snapshot finalization\n    trace.steps.push({\n      step: ++stepNum,\n      phase: \"snapshot_finalization\",\n      detail: `Chain hash: ${snapshot.chainHash.slice(0, 16)}`,\n      outputHash: snapshot.chainHash.slice(0, 16),\n    });\n  }\n\n  if (json) {\n    console.log(JSON.stringify(trace, null, 2));\n  } else {\n    console.log(`\\n=== Execution Trace: ${snapshot.runId} ===\\n`);\n    for (const step of trace.steps) {\n      console.log(`[Step ${step.step}] ${step.phase}`);\n      console.log(`  ${step.detail}`);\n      console.log(`  Hash: ${step.outputHash}...`);\n      console.log(\"\");\n    }\n  }\n\n  return 0;\n}\n\nexport async function runSnapshotsCommand(json: boolean): Promise<number> {\n  const { listSnapshots, loadSnapshot } = await import(\"@zeo/core\");\n\n  const ids = listSnapshots();\n  if (ids.length === 0) {\n    console.log(\"No snapshots found. Run a decision with --deterministic to create snapshots.\");\n    return 0;\n  }\n\n  if (json) {\n    const snapshots = ids\n      .map((id) => {\n        const s = loadSnapshot(id);\n        return s\n          ? {\n              runId: s.runId,\n              createdAt: s.createdAt,\n              deterministic: s.deterministic,\n              inputHash: s.inputHash,\n              outputHash: s.outputHash,\n            }\n          : null;\n      })\n      .filter(Boolean);\n    console.log(JSON.stringify(snapshots, null, 2));\n  } else {\n    console.log(`\\nSnapshots (${ids.length}):\\n`);\n    for (const id of ids) {\n      const s = loadSnapshot(id);\n      if (s) {\n        console.log(\n          `  ${s.runId} | ${s.createdAt} | ${s.deterministic ? \"deterministic\" : \"non-deterministic\"} | ${s.durationMs}ms`,\n        );\n      }\n    }\n  }\n\n  return 0;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\v3-cli.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'pending' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":571,"column":13,"messageId":"unusedVar","endLine":571,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @ts-nocheck\n/**\n * Zeo v3 CLI Module — Governed Multi-Tenant Decision Infrastructure\n *\n * Commands:\n *   tenant <cmd>      Tenant management (create/list/suspend/policy/usage)\n *   health             System health check report\n *   drift              Drift monitor events\n *   schemas            Schema registry listing\n *   compliance <cmd>   Compliance report / audit-chain / secret-scan\n *   modules <cmd>      Module registry (list/register/validate)\n *   simulate <cmd>     What-if simulation / forecast / sensitivity\n *   outcome <cmd>      Outcome registration / regret / optimization\n */\n\n// =============================================================================\n// ARGS PARSING\n// =============================================================================\n\nexport interface V3Args {\n  command: string;\n  subcommand?: string;\n  positionals: string[];\n  flags: Record<string, string | boolean>;\n}\n\nexport function parseV3Args(argv: string[]): V3Args {\n  const command = argv[0] ?? \"\";\n  const subcommand = argv[1];\n  const positionals: string[] = [];\n  const flags: Record<string, string | boolean> = {};\n\n  for (let i = 1; i < argv.length; i++) {\n    const arg = argv[i];\n    if (arg.startsWith(\"--\")) {\n      const key = arg.slice(2);\n      const next = argv[i + 1];\n      if (next && !next.startsWith(\"--\")) {\n        flags[key] = next;\n        i++;\n      } else {\n        flags[key] = true;\n      }\n    } else if (i > 1) {\n      positionals.push(arg);\n    }\n  }\n\n  return { command, subcommand, positionals, flags };\n}\n\n// =============================================================================\n// COMMAND ROUTER\n// =============================================================================\n\nexport async function runV3Command(args: V3Args): Promise<number> {\n  try {\n    switch (args.command) {\n      case \"tenant\":\n        return await runTenantCommand(args);\n      case \"health\":\n        return await runHealthCommand(args);\n      case \"drift\":\n        return await runDriftCommand(args);\n      case \"schemas\":\n        return await runSchemasCommand(args);\n      case \"compliance\":\n        return await runComplianceCommand(args);\n      case \"modules\":\n        return await runModulesCommand(args);\n      case \"simulate\":\n        return await runSimulateCommand(args);\n      case \"outcome\":\n        return await runOutcomeCommand(args);\n      default:\n        console.error(`Unknown v3 command: ${args.command}`);\n        return 1;\n    }\n  } catch (err) {\n    console.error(`[v3] Error: ${err instanceof Error ? err.message : String(err)}`);\n    return 1;\n  }\n}\n\n// =============================================================================\n// PHASE A: TENANT COMMANDS\n// =============================================================================\n\nasync function runTenantCommand(args: V3Args): Promise<number> {\n  const { tenantStore, formatUsage, formatPolicy } = await import(\"@zeo/tenant\");\n\n  switch (args.subcommand) {\n    case \"create\": {\n      const name = args.positionals[0] ?? (args.flags[\"name\"] as string) ?? \"default\";\n      const owner = (args.flags[\"owner\"] as string) ?? \"cli-user\";\n      const tenant = tenantStore.createTenant(name, owner);\n      console.log(`Tenant created: ${tenant.tenantId}`);\n      console.log(`  Name:    ${tenant.name}`);\n      console.log(`  Status:  ${tenant.status}`);\n      console.log(`  Created: ${tenant.createdAt}`);\n      return 0;\n    }\n\n    case \"list\": {\n      const tenants = tenantStore.listTenants();\n      if (tenants.length === 0) {\n        console.log(\"No tenants registered.\");\n      } else {\n        console.log(`=== Tenants (${tenants.length}) ===`);\n        for (const t of tenants) {\n          console.log(`  ${t.tenantId}: ${t.name} [${t.status}] (${t.createdAt})`);\n        }\n      }\n      return 0;\n    }\n\n    case \"suspend\": {\n      const tenantId = args.positionals[0] ?? (args.flags[\"id\"] as string);\n      if (!tenantId) {\n        console.error(\"Usage: zeo tenant suspend <tenant_id>\");\n        return 1;\n      }\n      tenantStore.suspendTenant(tenantId);\n      console.log(`Tenant ${tenantId} suspended.`);\n      return 0;\n    }\n\n    case \"policy\": {\n      const tenantId = args.positionals[0] ?? (args.flags[\"id\"] as string);\n      if (!tenantId) {\n        console.error(\"Usage: zeo tenant policy <tenant_id>\");\n        return 1;\n      }\n      const policy = tenantStore.getPolicy(tenantId);\n      console.log(formatPolicy(policy));\n      return 0;\n    }\n\n    case \"usage\": {\n      const tenantId = args.positionals[0] ?? (args.flags[\"id\"] as string);\n      if (!tenantId) {\n        console.error(\"Usage: zeo tenant usage <tenant_id>\");\n        return 1;\n      }\n      const usage = tenantStore.getUsage(tenantId);\n      console.log(formatUsage(usage));\n      return 0;\n    }\n\n    case \"assign-role\": {\n      const tenantId = args.positionals[0] ?? (args.flags[\"tenant\"] as string);\n      const userId = args.positionals[1] ?? (args.flags[\"user\"] as string);\n      const role = (args.positionals[2] ?? args.flags[\"role\"]) as string;\n      if (!tenantId || !userId || !role) {\n        console.error(\"Usage: zeo tenant assign-role <tenant_id> <user_id> <role>\");\n        return 1;\n      }\n      tenantStore.assignRole(tenantId, userId, role as \"owner\" | \"admin\" | \"operator\" | \"viewer\");\n      console.log(`Role ${role} assigned to ${userId} in tenant ${tenantId}`);\n      return 0;\n    }\n\n    default:\n      console.log(`Usage: zeo tenant <create|list|suspend|policy|usage|assign-role>`);\n      return 1;\n  }\n}\n\n// =============================================================================\n// PHASE B: HEALTH + DRIFT COMMANDS\n// =============================================================================\n\nasync function runHealthCommand(_args: V3Args): Promise<number> {\n  const {\n    healthRegistry,\n    formatHealthReport,\n    createPolicyEnforcementChecker,\n    createSchemaCompatibilityChecker,\n  } = await import(\"@zeo/observability\");\n\n  // Register built-in checkers\n  healthRegistry.register(\"policy_enforcement\", createPolicyEnforcementChecker(true));\n  healthRegistry.register(\"schema_compatibility\", createSchemaCompatibilityChecker(\"3.0.0\"));\n\n  const report = await healthRegistry.runAll();\n  console.log(formatHealthReport(report));\n  return report.overall === \"fail\" ? 1 : 0;\n}\n\nasync function runDriftCommand(args: V3Args): Promise<number> {\n  const { driftMonitor } = await import(\"@zeo/observability\");\n\n  if (args.subcommand === \"clear\") {\n    driftMonitor.clear();\n    console.log(\"Drift events cleared.\");\n    return 0;\n  }\n\n  console.log(driftMonitor.formatEvents());\n  console.log(`\\nDrift rate (last hour): ${driftMonitor.getDriftRate()}`);\n  console.log(`Active drift: ${driftMonitor.hasActiveDrift() ? \"YES\" : \"no\"}`);\n  return 0;\n}\n\n// =============================================================================\n// PHASE C: SCHEMA COMMANDS\n// =============================================================================\n\nasync function runSchemasCommand(args: V3Args): Promise<number> {\n  const { schemaRegistry, formatSchemaList } = await import(\"@zeo/schema-registry\");\n\n  if (args.subcommand === \"validate\") {\n    const schemaName = args.positionals[0];\n    const version = args.positionals[1] ? parseInt(args.positionals[1], 10) : undefined;\n    if (!schemaName) {\n      console.error(\"Usage: zeo schemas validate <schema_name> [version]\");\n      return 1;\n    }\n    const schema = schemaRegistry.getSchema(schemaName, version);\n    if (!schema) {\n      console.error(`Schema not found: ${schemaName}`);\n      return 1;\n    }\n    console.log(`Schema: ${schema.name} v${schema.version}`);\n    console.log(`Hash:   ${schema.hash}`);\n    console.log(`Fields: ${schema.fields.length}`);\n    for (const f of schema.fields) {\n      const req = f.required ? \"*\" : \" \";\n      console.log(`  ${req} ${f.name}: ${f.type}`);\n    }\n    return 0;\n  }\n\n  const schemas = schemaRegistry.listSchemas();\n  console.log(formatSchemaList(schemas));\n  return 0;\n}\n\n// =============================================================================\n// PHASE E: COMPLIANCE COMMANDS\n// =============================================================================\n\nasync function runComplianceCommand(args: V3Args): Promise<number> {\n  const {\n    complianceLedger,\n    generateComplianceReport,\n    formatComplianceReport,\n    scanForSecrets,\n    formatSecretScanResult,\n  } = await import(\"@zeo/compliance\");\n\n  switch (args.subcommand) {\n    case \"report\": {\n      const tenantId = args.positionals[0] ?? (args.flags[\"tenant\"] as string);\n      if (!tenantId) {\n        console.error(\"Usage: zeo compliance report <tenant_id>\");\n        return 1;\n      }\n      const report = generateComplianceReport(tenantId, complianceLedger);\n      console.log(formatComplianceReport(report));\n      return 0;\n    }\n\n    case \"audit-chain\": {\n      const result = complianceLedger.verifyChain();\n      if (result.valid) {\n        console.log(`✓ Audit chain valid (${complianceLedger.size()} entries)`);\n      } else {\n        console.error(`✗ Audit chain BROKEN at entry ${result.brokenAt}`);\n        console.error(`  ${result.details}`);\n        return 1;\n      }\n      return 0;\n    }\n\n    case \"secret-scan\": {\n      const target = args.positionals[0];\n      if (!target) {\n        console.error(\"Usage: zeo compliance secret-scan <text>\");\n        return 1;\n      }\n      const result = scanForSecrets(target, \"cli-input\");\n      console.log(formatSecretScanResult(result));\n      return result.clean ? 0 : 1;\n    }\n\n    default:\n      console.log(\"Usage: zeo compliance <report|audit-chain|secret-scan>\");\n      return 1;\n  }\n}\n\n// =============================================================================\n// PHASE D: MODULE COMMANDS\n// =============================================================================\n\nasync function runModulesCommand(args: V3Args): Promise<number> {\n  const { moduleRegistry, formatModuleList } = await import(\"@zeo/modules\");\n\n  switch (args.subcommand) {\n    case \"list\": {\n      const tenantId = args.flags[\"tenant\"] as string | undefined;\n      const modules = tenantId ? moduleRegistry.listByTenant(tenantId) : moduleRegistry.list();\n      console.log(formatModuleList(modules));\n      return 0;\n    }\n\n    case \"register\": {\n      const name = args.positionals[0] ?? (args.flags[\"name\"] as string);\n      const entrypoint = (args.flags[\"entrypoint\"] as string) ?? \"./index.js\";\n      const version = (args.flags[\"version\"] as string) ?? \"1.0.0\";\n      if (!name) {\n        console.error(\"Usage: zeo modules register <name> --entrypoint <path> --version <ver>\");\n        return 1;\n      }\n      const { nanoid } = await import(\"nanoid\");\n      moduleRegistry.register({\n        moduleId: `mod_${nanoid(12)}`,\n        name,\n        version,\n        entrypoint,\n        capabilities: [\"read_evidence\", \"read_config\"],\n        dependencies: [],\n        author: \"cli-user\",\n        description: `Module ${name}`,\n        deterministic: true,\n        hash: \"\",\n        tenantId: args.flags[\"tenant\"] as string | undefined, // Support tenant isolation\n        createdAt: new Date().toISOString(),\n      });\n      console.log(`Module \"${name}\" registered.`);\n      return 0;\n    }\n\n    case \"validate\": {\n      const moduleId = args.positionals[0];\n      if (!moduleId) {\n        console.error(\"Usage: zeo modules validate <module_id>\");\n        return 1;\n      }\n      const errors = moduleRegistry.validateDependencies(moduleId);\n      if (errors.length === 0) {\n        console.log(`✓ Module ${moduleId} dependencies valid.`);\n      } else {\n        console.error(`✗ Module ${moduleId} has dependency errors:`);\n        for (const e of errors) console.error(`  - ${e}`);\n        return 1;\n      }\n      return 0;\n    }\n\n    case \"order\": {\n      try {\n        const order = moduleRegistry.getDependencyOrder();\n        console.log(\"=== Dependency Order ===\");\n        order.forEach((id, i) => console.log(`  ${i + 1}. ${id}`));\n      } catch (err) {\n        console.error(`Cycle detected: ${err instanceof Error ? err.message : err}`);\n        return 1;\n      }\n      return 0;\n    }\n\n    default:\n      console.log(\"Usage: zeo modules <list|register|validate|order>\");\n      return 1;\n  }\n}\n\n// =============================================================================\n// PHASE F: SIMULATION COMMANDS\n// =============================================================================\n\nasync function runSimulateCommand(args: V3Args): Promise<number> {\n  const {\n    whatIfEngine,\n    forecastEngine,\n    confidenceStore,\n    computeSensitivity,\n    formatWhatIfResult,\n    formatForecast,\n    formatConfidenceTracker,\n    formatSensitivity,\n  } = await import(\"@zeo/simulation\");\n\n  switch (args.subcommand) {\n    case \"what-if\": {\n      const name = args.positionals[0] ?? \"default-scenario\";\n      const baseDecisionId = (args.flags[\"decision\"] as string) ?? \"decision-0\";\n\n      // Create a demo scenario\n      const tenantId = args.flags[\"tenant\"] as string | undefined;\n      const scenario = whatIfEngine.createScenario(\n        name,\n        baseDecisionId,\n        [\n          {\n            assumptionId: \"market_stress\",\n            originalValue: 0.5,\n            modifiedValue: 0.8,\n          },\n          {\n            assumptionId: \"timeline_pressure\",\n            originalValue: 0.3,\n            modifiedValue: 0.6,\n          },\n        ],\n        { tenantId },\n      );\n\n      // Simulate with deterministic runners\n      const result = whatIfEngine.simulate(\n        scenario.id,\n        (_modified) => ({\n          selectedAction: \"action-b\",\n          confidence: 0.65,\n          expectedUtility: 0.72,\n          risk: 0.35,\n          robustness: 0.58,\n        }),\n        () => ({\n          selectedAction: \"action-a\",\n          confidence: 0.78,\n          expectedUtility: 0.85,\n          risk: 0.2,\n          robustness: 0.72,\n        }),\n        (args.flags[\"seed\"] as string) ?? undefined,\n      );\n\n      console.log(formatWhatIfResult(result));\n      return 0;\n    }\n\n    case \"forecast\": {\n      const decisionId = (args.flags[\"decision\"] as string) ?? \"decision-0\";\n      const days = parseInt((args.flags[\"days\"] as string) ?? \"30\", 10);\n      const seed = (args.flags[\"seed\"] as string) ?? `forecast-${decisionId}`;\n      // If seeded (deterministic), default to a fixed start date if not provided\n      const defaultDate = args.flags[\"seed\"] ? \"2024-01-01T00:00:00.000Z\" : undefined;\n      const startDate = (args.flags[\"start-date\"] as string) ?? defaultDate;\n\n      const projection = forecastEngine.project(\n        decisionId,\n        {\n          selectedAction: \"action-a\",\n          confidence: 0.78,\n          expectedUtility: 0.85,\n          risk: 0.2,\n          robustness: 0.72,\n        },\n        { market_stress: 0.5, timeline_pressure: 0.3 },\n        days,\n        seed,\n        startDate,\n      );\n\n      console.log(formatForecast(projection));\n      return 0;\n    }\n\n    case \"confidence\": {\n      const decisionId = (args.flags[\"decision\"] as string) ?? \"decision-0\";\n      const tracker = confidenceStore.getOrCreate(decisionId, 0.5);\n      console.log(formatConfidenceTracker(tracker));\n      return 0;\n    }\n\n    case \"sensitivity\": {\n      const assumptions = [\n        { id: \"market_stress\", label: \"Market Stress\", value: 0.5 },\n        { id: \"counterparty_trust\", label: \"Counterparty Trust\", value: 0.7 },\n        { id: \"timeline_pressure\", label: \"Timeline Pressure\", value: 0.3 },\n      ];\n\n      const baseOutcome = {\n        selectedAction: \"action-a\",\n        confidence: 0.78,\n        expectedUtility: 0.85,\n        risk: 0.2,\n        robustness: 0.72,\n      };\n\n      const entries = computeSensitivity(\n        assumptions,\n        (modified) => ({\n          selectedAction: \"action-a\",\n          confidence: Math.max(\n            0,\n            Math.min(\n              1,\n              0.78 -\n                (modified[\"market_stress\"] - 0.5) * 0.3 +\n                (modified[\"counterparty_trust\"] - 0.7) * 0.2 -\n                (modified[\"timeline_pressure\"] - 0.3) * 0.15,\n            ),\n          ),\n          expectedUtility: 0.85,\n          risk: 0.2,\n          robustness: 0.72,\n        }),\n        baseOutcome,\n      );\n\n      console.log(formatSensitivity(entries));\n      return 0;\n    }\n\n    default:\n      console.log(\"Usage: zeo simulate <what-if|forecast|confidence|sensitivity>\");\n      return 1;\n  }\n}\n\n// =============================================================================\n// PHASE G: OUTCOME COMMANDS\n// =============================================================================\n\nasync function runOutcomeCommand(args: V3Args): Promise<number> {\n  const {\n    outcomeStore,\n    assumptionTuner,\n    computeRegret,\n    generateOptimizationSummary,\n    formatRegret,\n    formatOptimizationSummary,\n    formatAdjustments,\n  } = await import(\"@zeo/optimization\");\n\n  switch (args.subcommand) {\n    case \"register\": {\n      const decisionId = (args.flags[\"decision\"] as string) ?? \"decision-0\";\n      const action = (args.flags[\"action\"] as string) ?? \"action-a\";\n      const actual = (args.flags[\"actual\"] as string) ?? \"success\";\n      const utility = parseFloat((args.flags[\"utility\"] as string) ?? \"0.8\");\n      const predicted = parseFloat((args.flags[\"predicted\"] as string) ?? \"0.85\");\n      const user = (args.flags[\"user\"] as string) ?? \"cli-user\";\n\n      const outcome = outcomeStore.register(decisionId, action, actual, utility, predicted, user);\n\n      console.log(`Outcome registered: ${outcome.id}`);\n      console.log(`  Decision: ${outcome.decisionId}`);\n      console.log(`  Action:   ${outcome.selectedAction}`);\n      console.log(`  Outcome:  ${outcome.actualOutcome}`);\n      console.log(\n        `  Utility:  observed=${outcome.observedUtility}, predicted=${outcome.predictedUtility}`,\n      );\n      return 0;\n    }\n\n    case \"regret\": {\n      const decisionId = (args.flags[\"decision\"] as string) ?? \"decision-0\";\n      const outcomes = outcomeStore.getByDecision(decisionId);\n      if (outcomes.length === 0) {\n        console.log(`No outcomes for decision: ${decisionId}`);\n        return 0;\n      }\n\n      for (const outcome of outcomes) {\n        const analysis = computeRegret(outcome, [\n          { action: \"action-b\", utility: outcome.observedUtility * 0.9 },\n          { action: \"action-c\", utility: outcome.observedUtility * 1.1 },\n        ]);\n        console.log(formatRegret(analysis));\n        console.log();\n      }\n      return 0;\n    }\n\n    case \"adjust\": {\n      const pending = assumptionTuner.getPending();\n      if (args.positionals[0] === \"list\") {\n        console.log(formatAdjustments(assumptionTuner.getAll()));\n        return 0;\n      }\n\n      const adjustmentId = args.positionals[0];\n      const action = args.positionals[1]; // approve | reject\n      if (!adjustmentId || !action) {\n        console.log(\"Usage: zeo outcome adjust <adjustment_id> <approve|reject>\");\n        console.log(\"       zeo outcome adjust list\");\n        return 1;\n      }\n\n      const user = (args.flags[\"user\"] as string) ?? \"cli-user\";\n      if (action === \"approve\") {\n        const adj = assumptionTuner.approve(adjustmentId, user);\n        if (adj) {\n          console.log(`✓ Adjustment ${adjustmentId} approved by ${user}`);\n        } else {\n          console.error(`Could not approve ${adjustmentId}`);\n          return 1;\n        }\n      } else if (action === \"reject\") {\n        const adj = assumptionTuner.reject(adjustmentId, user);\n        if (adj) {\n          console.log(`✗ Adjustment ${adjustmentId} rejected by ${user}`);\n        } else {\n          console.error(`Could not reject ${adjustmentId}`);\n          return 1;\n        }\n      }\n      return 0;\n    }\n\n    case \"summary\": {\n      const outcomes = outcomeStore.getAll();\n      const regrets = outcomes.map((o) =>\n        computeRegret(o, [\n          { action: \"alt-a\", utility: o.observedUtility * 0.95 },\n          { action: \"alt-b\", utility: o.observedUtility * 1.05 },\n        ]),\n      );\n      const summary = generateOptimizationSummary(outcomes, regrets, assumptionTuner.getAll());\n      console.log(formatOptimizationSummary(summary));\n      return 0;\n    }\n\n    default:\n      console.log(\"Usage: zeo outcome <register|regret|adjust|summary>\");\n      return 1;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\view-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\warehouse-cli.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'unlinkSync' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":62,"messageId":"unusedVar","endLine":2,"endColumn":72,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"unlinkSync"},"fix":{"range":[74,86],"text":""},"desc":"Remove unused variable \"unlinkSync\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FilesystemBlobStorage' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":38,"messageId":"unusedVar","endLine":4,"endColumn":59,"suggestions":[{"messageId":"removeUnusedVar","data":{"varName":"FilesystemBlobStorage"},"fix":{"range":[183,206],"text":""},"desc":"Remove unused variable \"FilesystemBlobStorage\"."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'WAREHOUSE_DIR' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":14,"column":7,"messageId":"unusedVar","endLine":14,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// @ts-nocheck\nimport { writeFileSync, existsSync, mkdirSync, readFileSync, unlinkSync } from \"node:fs\";\nimport { resolve, join } from \"node:path\";\nimport { FilesystemWarehouseAdapter, FilesystemBlobStorage } from \"@zeo/warehouse\";\nimport {\n  buildDataset,\n  datasetToCsv,\n  runCorrelation,\n  runRegression,\n  generateReport,\n} from \"@zeo/analytics\";\nimport type { WarehouseKind, ExportOptions, WarehouseEnvelope } from \"@zeo/contracts\";\n\nconst WAREHOUSE_DIR = \".zeo/warehouse\";\nconst METADATA_DIR = \".zeo/metadata\";\nconst RETENTION_CONFIG_FILE = \"retention.json\";\nconst PINNED_FILE = \"pinned.json\";\n\ninterface RetentionConfig {\n  defaultRetentionDays: number;\n  perKindRetention: Record<string, number>;\n  lastUpdated: string;\n}\n\ninterface PinnedRecords {\n  pinnedIds: string[];\n  lastUpdated: string;\n}\n\ninterface WarehouseCliArgs {\n  command: \"export\" | \"import\" | \"list\" | \"prune\" | \"pin\" | \"unpin\" | \"retention\" | null;\n  out?: string;\n  input?: string;\n  kinds?: WarehouseKind[];\n  tags?: string[];\n  dryRun?: boolean;\n  retentionDays?: number;\n  pin?: boolean;\n  id?: string;\n}\n\ninterface AnalyticsCliArgs {\n  command: \"build-dataset\" | \"run\" | null;\n  datasetPath?: string;\n  outDir?: string;\n  targetCol?: string;\n  featureCols?: string[];\n}\n\n// Retention policy helper functions\nasync function getRetentionConfig(cwd: string): Promise<RetentionConfig> {\n  const configPath = resolve(cwd, METADATA_DIR, RETENTION_CONFIG_FILE);\n\n  try {\n    const data = readFileSync(configPath, \"utf8\");\n    return JSON.parse(data);\n  } catch {\n    // Default config\n    return {\n      defaultRetentionDays: 90,\n      perKindRetention: {\n        decision: 90,\n        outcome: 180,\n        \"decision-draft\": 30,\n        \"evidence-event\": 180,\n        \"signal-observation\": 90,\n        \"observation-batch\": 90,\n        \"run-result\": 60,\n        \"outcome-record\": 180,\n        \"calibration-report\": 365,\n      },\n      lastUpdated: new Date().toISOString(),\n    };\n  }\n}\n\nasync function saveRetentionConfig(cwd: string, config: RetentionConfig): Promise<void> {\n  const configPath = resolve(cwd, METADATA_DIR, RETENTION_CONFIG_FILE);\n  const configDir = resolve(cwd, METADATA_DIR);\n\n  if (!existsSync(configDir)) {\n    mkdirSync(configDir, { recursive: true });\n  }\n\n  writeFileSync(configPath, JSON.stringify(config, null, 2), \"utf8\");\n}\n\nasync function getPinnedRecords(cwd: string): Promise<PinnedRecords> {\n  const pinnedPath = resolve(cwd, METADATA_DIR, PINNED_FILE);\n\n  try {\n    const data = readFileSync(pinnedPath, \"utf8\");\n    const parsed = JSON.parse(data);\n    return {\n      pinnedIds: parsed.pinnedIds || [],\n      lastUpdated: parsed.lastUpdated || new Date().toISOString(),\n    };\n  } catch {\n    return {\n      pinnedIds: [],\n      lastUpdated: new Date().toISOString(),\n    };\n  }\n}\n\nasync function savePinnedRecords(cwd: string, pinned: PinnedRecords): Promise<void> {\n  const pinnedPath = resolve(cwd, METADATA_DIR, PINNED_FILE);\n  const metadataDir = resolve(cwd, METADATA_DIR);\n\n  if (!existsSync(metadataDir)) {\n    mkdirSync(metadataDir, { recursive: true });\n  }\n\n  writeFileSync(pinnedPath, JSON.stringify(pinned, null, 2), \"utf8\");\n}\n\nfunction isExpired(\n  envelope: WarehouseEnvelope<unknown>,\n  retentionDays: number,\n  pinnedIds: string[],\n): boolean {\n  // Never expire pinned records\n  if (pinnedIds.includes(envelope.id)) {\n    return false;\n  }\n\n  // Never expire if no retention days specified\n  if (!retentionDays || retentionDays <= 0) {\n    return false;\n  }\n\n  const createdAt = new Date(envelope.createdAt);\n  const now = new Date();\n  const ageMs = now.getTime() - createdAt.getTime();\n  const ageDays = ageMs / (1000 * 60 * 60 * 24);\n\n  return ageDays > retentionDays;\n}\n\nexport function parseWarehouseArgs(argv: string[]): WarehouseCliArgs {\n  const result: WarehouseCliArgs = {\n    command: null,\n    id: null,\n  };\n\n  for (let i = 0; i < argv.length; i++) {\n    const arg = argv[i];\n    const next = argv[i + 1];\n\n    if (arg === \"export\") {\n      result.command = \"export\";\n    } else if (arg === \"import\") {\n      result.command = \"import\";\n    } else if (arg === \"list\") {\n      result.command = \"list\";\n    } else if (arg === \"prune\") {\n      result.command = \"prune\";\n    } else if (arg === \"pin\") {\n      result.command = \"pin\";\n    } else if (arg === \"unpin\") {\n      result.command = \"unpin\";\n    } else if (arg === \"retention\") {\n      result.command = \"retention\";\n    } else if (arg === \"--out\" && next) {\n      result.out = next;\n      i++;\n    } else if (arg === \"--in\" && next) {\n      result.input = next;\n      i++;\n    } else if (arg === \"--kinds\" && next) {\n      result.kinds = next.split(\",\") as WarehouseKind[];\n      i++;\n    } else if (arg === \"--tags\" && next) {\n      result.tags = next.split(\",\");\n      i++;\n    } else if (arg === \"--dry-run\") {\n      result.dryRun = true;\n    } else if (arg === \"--retention-days\" && next) {\n      result.retentionDays = parseInt(next, 10);\n      i++;\n    } else if (arg === \"--pin\") {\n      result.pin = true;\n    } else if (arg === \"--id\" && next) {\n      result.id = next;\n      i++;\n    }\n  }\n\n  return result;\n}\n\nexport function parseAnalyticsArgs(argv: string[]): AnalyticsCliArgs {\n  const result: AnalyticsCliArgs = {\n    command: null,\n  };\n\n  for (let i = 0; i < argv.length; i++) {\n    const arg = argv[i];\n    const next = argv[i + 1];\n\n    if (arg === \"build-dataset\") {\n      result.command = \"build-dataset\";\n    } else if (arg === \"run\") {\n      result.command = \"run\";\n    } else if (arg === \"--out\" && next) {\n      result.outDir = next;\n      i++;\n    } else if (arg === \"--dataset\" && next) {\n      result.datasetPath = next;\n      i++;\n    } else if (arg === \"--target\" && next) {\n      result.targetCol = next;\n      i++;\n    } else if (arg === \"--features\" && next) {\n      result.featureCols = next.split(\",\");\n      i++;\n    }\n  }\n\n  return result;\n}\n\nexport async function runWarehouseCommand(args: WarehouseCliArgs): Promise<number> {\n  const warehouse = new FilesystemWarehouseAdapter();\n\n  if (!args.command) {\n    console.log(`\n Zeo Warehouse CLI\n\n Usage: zeo --warehouse <command> [options]\n\n Commands:\n   export              Export records to bundle\n   import              Import records from bundle\n   list                List records in warehouse\n   prune               Remove old/expired records (respects pinned items)\n   pin                 Pin a record to prevent pruning\n   unpin               Unpin a record\n   retention           View or set retention policies\n\n Options:\n   --out <path>        Output file path (for export)\n   --in <path>         Input file path (for import)\n   --kinds <list>       Comma-separated list of record kinds\n   --tags <list>       Comma-separated list of tags to filter\n   --dry-run           Show what would be pruned without actually pruning\n   --retention-days    Set default retention period (days)\n   --id <record-id>    Record ID for pin/unpin commands\n\n Examples:\n   zeo --warehouse export --out ./backup.json --kinds decision,outcome\n   zeo --warehouse import --in ./backup.json\n   zeo --warehouse list --tags important\n   zeo --warehouse prune --dry-run --kinds decision --retention-days 30\n   zeo --warehouse pin --id <record-id>\n   zeo --warehouse unpin --id <record-id>\n   zeo --warehouse retention --retention-days 30\n   zeo --warehouse retention\n `);\n    return 0;\n  }\n\n  switch (args.command) {\n    case \"export\": {\n      if (!args.out) {\n        console.error(\"Error: --out is required for export\");\n        return 1;\n      }\n\n      const options: ExportOptions = {\n        kinds: args.kinds,\n        tags: args.tags,\n      };\n\n      console.log(\"Exporting warehouse records...\");\n      const bundle = await warehouse.exportBundle(options);\n\n      const outPath = resolve(args.out);\n      writeFileSync(outPath, JSON.stringify(bundle, null, 2), \"utf8\");\n\n      console.log(`Exported ${bundle.recordCount} records to ${args.out}`);\n      return 0;\n    }\n\n    case \"import\": {\n      if (!args.input) {\n        console.error(\"Error: --in is required for import\");\n        return 1;\n      }\n\n      const inputPath = resolve(args.input);\n      if (!existsSync(inputPath)) {\n        console.error(`Error: File not found: ${args.input}`);\n        return 1;\n      }\n\n      console.log(\"Importing warehouse records...\");\n      const bundle = JSON.parse(readFileSync(inputPath, \"utf8\"));\n\n      const result = await warehouse.importBundle(bundle, {\n        type: \"prefer-newer\",\n        sameHashAction: \"skip\",\n      });\n\n      console.log(`Import complete:`);\n      console.log(`  Imported: ${result.imported}`);\n      console.log(`  Skipped (same hash): ${result.skipped}`);\n      console.log(`  Conflicts: ${result.conflicts}`);\n      return 0;\n    }\n\n    case \"list\": {\n      const result = await warehouse.list({\n        kinds: args.kinds,\n        tags: args.tags,\n        limit: 100,\n      });\n\n      console.log(`Found ${result.items.length} records:\\n`);\n      for (const item of result.items) {\n        console.log(`  ${item.id} [${item.kind}]`);\n        console.log(`    Created: ${item.createdAt}`);\n        console.log(`    Hash: ${item.hashes.contentHash.slice(0, 16)}...`);\n        if (item.tags && item.tags.length > 0) {\n          console.log(`    Tags: ${item.tags.join(\", \")}`);\n        }\n        console.log();\n      }\n      return 0;\n    }\n\n    case \"prune\": {\n      const retentionConfig = await getRetentionConfig(process.cwd());\n      const pinned = await getPinnedRecords(process.cwd());\n      const now = new Date();\n\n      // Get all records\n      const allRecords = await warehouse.list({\n        kinds: args.kinds,\n        tags: args.tags,\n        includeDeleted: false,\n      });\n\n      const expiredRecords: Array<{\n        id: string;\n        kind: WarehouseKind;\n        ageDays: number;\n        reason: string;\n      }> = [];\n\n      for (const record of allRecords.items) {\n        const retentionDays =\n          retentionConfig.perKindRetention[record.kind] || retentionConfig.defaultRetentionDays;\n\n        if (isExpired(record, retentionDays, pinned.pinnedIds)) {\n          const createdAt = new Date(record.createdAt);\n          const ageMs = now.getTime() - createdAt.getTime();\n          const ageDays = Math.floor(ageMs / (1000 * 60 * 60 * 24));\n\n          expiredRecords.push({\n            id: record.id,\n            kind: record.kind,\n            ageDays,\n            reason: `Older than ${retentionDays} days (${record.kind} retention)`,\n          });\n        }\n      }\n\n      if (expiredRecords.length === 0) {\n        console.log(\"No expired records found matching criteria.\");\n        console.log(`\\nRetention settings used:`);\n        console.log(`  Default: ${retentionConfig.defaultRetentionDays} days`);\n        console.log(`  Pinned records: ${pinned.pinnedIds.length}`);\n        return 0;\n      }\n\n      console.log(`Found ${expiredRecords.length} expired record(s):\\n`);\n\n      for (const record of expiredRecords) {\n        console.log(`  ${record.id} [${record.kind}]`);\n        console.log(`    Age: ${record.ageDays} days - ${record.reason}`);\n      }\n\n      if (args.dryRun) {\n        console.log(`\\n[Dry run] Would prune ${expiredRecords.length} record(s)`);\n        console.log(\"No changes made.\");\n        return 0;\n      }\n\n      let pruned = 0;\n      for (const record of expiredRecords) {\n        try {\n          await warehouse.delete(record.kind, record.id);\n          pruned++;\n          console.log(`  Pruned: ${record.id}`);\n        } catch (err) {\n          console.error(\n            `  Failed to prune ${record.id}:`,\n            err instanceof Error ? err.message : err,\n          );\n        }\n      }\n\n      console.log(`\\nPruned ${pruned}/${expiredRecords.length} records`);\n      return 0;\n    }\n\n    case \"pin\": {\n      if (!args.id) {\n        console.error(\"Error: --id is required for pin command\");\n        return 1;\n      }\n\n      // Check if record exists\n      const allRecords = await warehouse.list({ limit: 1000 });\n      const record = allRecords.items.find((r) => r.id === args.id);\n\n      if (!record) {\n        console.error(`Error: Record not found: ${args.id}`);\n        return 1;\n      }\n\n      const pinned = await getPinnedRecords(process.cwd());\n\n      if (pinned.pinnedIds.includes(args.id!)) {\n        console.log(`Record ${args.id} is already pinned`);\n        return 0;\n      }\n\n      pinned.pinnedIds.push(args.id!);\n      pinned.lastUpdated = new Date().toISOString();\n      await savePinnedRecords(process.cwd(), pinned);\n\n      console.log(`Pinned record: ${args.id} [${record.kind}]`);\n      console.log(`Total pinned: ${pinned.pinnedIds.length}`);\n      return 0;\n    }\n\n    case \"unpin\": {\n      if (!args.id) {\n        console.error(\"Error: --id is required for unpin command\");\n        return 1;\n      }\n\n      const pinned = await getPinnedRecords(process.cwd());\n\n      if (!pinned.pinnedIds.includes(args.id!)) {\n        console.log(`Record ${args.id} is not pinned`);\n        return 0;\n      }\n\n      pinned.pinnedIds = pinned.pinnedIds.filter((id) => id !== args.id);\n      pinned.lastUpdated = new Date().toISOString();\n      await savePinnedRecords(process.cwd(), pinned);\n\n      console.log(`Unpinned record: ${args.id}`);\n      console.log(`Total pinned: ${pinned.pinnedIds.length}`);\n      return 0;\n    }\n\n    case \"retention\": {\n      if (args.retentionDays !== undefined) {\n        const retentionDays = Math.max(1, args.retentionDays);\n        const config = await getRetentionConfig(process.cwd());\n        config.defaultRetentionDays = retentionDays;\n        config.lastUpdated = new Date().toISOString();\n        await saveRetentionConfig(process.cwd(), config);\n\n        console.log(`Set default retention period to ${retentionDays} days`);\n        console.log(\"\\nRetention by record kind:\");\n        for (const [kind, days] of Object.entries(config.perKindRetention)) {\n          console.log(`  ${kind}: ${days} days`);\n        }\n        return 0;\n      }\n\n      const config = await getRetentionConfig(process.cwd());\n      const pinned = await getPinnedRecords(process.cwd());\n\n      console.log(\"Retention Policy Settings:\");\n      console.log(`  Default retention: ${config.defaultRetentionDays} days`);\n      console.log(`  Pinned records: ${pinned.pinnedIds.length} (never expire)`);\n      console.log(\"\\nRetention by record kind:\");\n      for (const [kind, days] of Object.entries(config.perKindRetention)) {\n        console.log(`  ${kind}: ${days} days`);\n      }\n\n      if (pinned.pinnedIds.length > 0) {\n        console.log(\"\\nPinned records:\");\n        for (const id of pinned.pinnedIds) {\n          console.log(`  ${id}`);\n        }\n      }\n\n      return 0;\n    }\n\n    default:\n      console.error(`Unknown command: ${args.command}`);\n      return 1;\n  }\n}\n\nexport async function runAnalyticsCommand(args: AnalyticsCliArgs): Promise<number> {\n  if (!args.command) {\n    console.log(`\nZeo Analytics CLI\n\nUsage: zeo --analytics <command> [options]\n\nCommands:\n  build-dataset       Build feature dataset from warehouse\n  run                 Run correlation and regression analysis\n\nOptions:\n  --out <dir>         Output directory\n  --dataset <path>    Path to dataset CSV (for run command)\n  --target <col>      Target column name (for regression)\n  --features <list>   Comma-separated feature columns (for regression)\n\nExamples:\n  zeo --analytics build-dataset --out ./analysis\n  zeo --analytics run --dataset ./analysis/dataset.csv --out ./analysis --target outcome --features feature1,feature2\n`);\n    return 0;\n  }\n\n  switch (args.command) {\n    case \"build-dataset\": {\n      if (!args.outDir) {\n        console.error(\"Error: --out is required\");\n        return 1;\n      }\n\n      const warehouse = new FilesystemWarehouseAdapter();\n      console.log(\"Building dataset from warehouse...\");\n\n      const dataset = await buildDataset(warehouse, {\n        includeDecisions: true,\n        includeOutcomes: true,\n        includeRuns: true,\n      });\n\n      const outPath = resolve(args.outDir);\n      if (!existsSync(outPath)) {\n        mkdirSync(outPath, { recursive: true });\n      }\n\n      // Write CSV\n      const csv = datasetToCsv(dataset);\n      const csvPath = join(outPath, \"dataset.csv\");\n      writeFileSync(csvPath, csv, \"utf8\");\n\n      // Write schema\n      const schemaPath = join(outPath, \"dataset_schema.json\");\n      writeFileSync(schemaPath, JSON.stringify(dataset.schema, null, 2), \"utf8\");\n\n      console.log(`Dataset written to ${outPath}:`);\n      console.log(`  - ${csvPath} (${dataset.rows.length} rows)`);\n      console.log(`  - ${schemaPath}`);\n      console.log(`\\nDataset hash: ${dataset.schema.provenance.datasetHash}`);\n\n      return 0;\n    }\n\n    case \"run\": {\n      if (!args.datasetPath) {\n        console.error(\"Error: --dataset is required\");\n        return 1;\n      }\n\n      if (!args.outDir) {\n        console.error(\"Error: --out is required\");\n        return 1;\n      }\n\n      const datasetPath = resolve(args.datasetPath);\n      if (!existsSync(datasetPath)) {\n        console.error(`Error: Dataset not found: ${args.datasetPath}`);\n        return 1;\n      }\n\n      const outPath = resolve(args.outDir);\n      if (!existsSync(outPath)) {\n        mkdirSync(outPath, { recursive: true });\n      }\n\n      console.log(\"Running analytics pipeline...\");\n      console.log(\n        \"Note: Python backend required (numpy, pandas, scipy, scikit-learn, statsmodels)\",\n      );\n      console.log();\n\n      // Run correlation\n      console.log(\"Computing correlations...\");\n      const correlationsPath = join(outPath, \"correlations.json\");\n      try {\n        const correlations = await runCorrelation(datasetPath, correlationsPath, {\n          includeRobust: true,\n        });\n        console.log(`  Correlations saved to ${correlationsPath}`);\n        console.log(`  Variables analyzed: ${correlations?.variables.join(\", \")}`);\n      } catch (err) {\n        console.error(\"  Correlation failed:\", err instanceof Error ? err.message : err);\n        console.error(\n          \"  Ensure Python dependencies are installed: pip install -r packages/analytics/python/requirements.txt\",\n        );\n      }\n\n      // Run regression if target specified\n      if (args.targetCol && args.featureCols && args.featureCols.length > 0) {\n        console.log(\"\\nRunning regression...\");\n        const regressionsPath = join(outPath, \"regressions.json\");\n        try {\n          const regressions = await runRegression(datasetPath, regressionsPath, {\n            targetCol: args.targetCol,\n            featureCols: args.featureCols,\n          });\n          console.log(`  Regressions saved to ${regressionsPath}`);\n          console.log(`  Target: ${regressions?.target}`);\n          console.log(`  Features: ${regressions?.features.join(\", \")}`);\n\n          if (regressions?.epistemic_label) {\n            console.log(`\\n  Epistemic Label: ${regressions.epistemic_label}`);\n            console.log(`  Note: ${regressions.epistemic_note}`);\n          }\n        } catch (err) {\n          console.error(\"  Regression failed:\", err instanceof Error ? err.message : err);\n        }\n      }\n\n      // Generate report\n      console.log(\"\\nGenerating report...\");\n      try {\n        const correlationsData = existsSync(correlationsPath)\n          ? JSON.parse(readFileSync(correlationsPath, \"utf8\"))\n          : undefined;\n        const regressionsData = existsSync(join(outPath, \"regressions.json\"))\n          ? JSON.parse(readFileSync(join(outPath, \"regressions.json\"), \"utf8\"))\n          : undefined;\n\n        const datasetHash = \"unknown\";\n        const report = await generateReport(correlationsData, regressionsData, datasetHash);\n\n        const reportPath = join(outPath, \"analytics_report.md\");\n        writeFileSync(reportPath, report, \"utf8\");\n        console.log(`  Report saved to ${reportPath}`);\n      } catch (err) {\n        console.error(\"  Report generation failed:\", err instanceof Error ? err.message : err);\n      }\n\n      console.log(\"\\nAnalytics complete.\");\n      return 0;\n    }\n\n    default:\n      console.error(`Unknown command: ${args.command}`);\n      return 1;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\workflow-cli.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\workflow-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\cli\\zeolite-cli.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\core\\doctor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\core\\env.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":83,"messageId":"unexpectedAny","endLine":67,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1629,1632],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1629,1632],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":61,"messageId":"unexpectedAny","endLine":74,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1893,1896],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1893,1896],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Reach Core Environment Configuration\n *\n * Provides typed, fail-fast configuration validation.\n * Eliminates silent fallback drift.\n */\n\nexport interface ReachConfig {\n  NODE_ENV: string;\n  CI: boolean;\n  DEBUG: boolean;\n\n  // Platform\n  ZEO_STRICT: boolean;\n  ZEO_FIXED_TIME?: string;\n  ZEO_WORKSPACE_ID: string;\n  PORT?: number;\n\n  // Observability\n  ZEO_LOG_REDACT: \"none\" | \"safe\" | \"strict\";\n  ZEO_LOG_FORMAT: \"text\" | \"json\";\n\n  // Provider\n  OPENAI_API_KEY?: string;\n  ANTHROPIC_API_KEY?: string;\n  OPENROUTER_API_KEY?: string;\n  SUPABASE_URL?: string;\n  SUPABASE_SERVICE_KEY?: string;\n\n  // LLM Configuration (for llm-cli.ts)\n  ZEO_LLM_PROVIDER?: string;\n  ZEO_LLM_MODEL?: string;\n  ZEO_LLM_BASE_URL?: string;\n  ZEO_LLM_API_KEY?: string;\n  ZEO_LLM_SEED?: string;\n\n  // Control Plane routing\n  ZEO_MODEL: string;\n  ZEO_PROVIDER: string;\n  KEYS_MODEL: string;\n  KEYS_PROVIDER: string;\n  READYLAYER_MODEL: string;\n  READYLAYER_PROVIDER: string;\n  SETTLER_MODEL: string;\n  SETTLER_PROVIDER: string;\n\n  // Security\n  ZEO_SIGNING_HMAC_KEY?: string;\n\n  // Integrations\n  GITHUB_TOKEN?: string;\n  SLACK_WEBHOOK_URL?: string;\n\n  // Extensions\n  ZEO_PLUGIN_PATH?: string;\n}\n\nfunction parseBoolean(val: string | undefined, defaultVal: boolean): boolean {\n  if (!val) return defaultVal;\n  const lower = val.toLowerCase().trim();\n  return lower === \"true\" || lower === \"1\" || lower === \"yes\";\n}\n\nfunction parseRedactMode(val: string | undefined): \"none\" | \"safe\" | \"strict\" {\n  if (!val) return \"safe\";\n  const lower = val.toLowerCase().trim();\n  if (lower === \"none\" || lower === \"safe\" || lower === \"strict\") return lower as any;\n  throw new Error(`Invalid ZEO_LOG_REDACT value: ${val}`);\n}\n\nfunction parseLogFormat(val: string | undefined): \"text\" | \"json\" {\n  if (!val) return \"text\";\n  const lower = val.toLowerCase().trim();\n  if (lower === \"text\" || lower === \"json\") return lower as any;\n  throw new Error(`Invalid ZEO_LOG_FORMAT value: ${val}`);\n}\n\nlet cachedConfig: ReachConfig | null = null;\n\nexport function loadConfig(): ReachConfig {\n  if (cachedConfig) return cachedConfig;\n\n  // Do not allow silent fallbacks for structurally critical features unless explicitly defined.\n  // We'll throw if strict required fields are missing but not all are required.\n  const config: ReachConfig = {\n    NODE_ENV: process.env.NODE_ENV || \"development\",\n    CI: parseBoolean(process.env.CI, false),\n    DEBUG: parseBoolean(process.env.DEBUG, false),\n\n    ZEO_STRICT: process.env.ZE0_STRICT\n      ? process.env.ZE0_STRICT !== \"0\" && process.env.ZE0_STRICT !== \"false\"\n      : parseBoolean(process.env.ZEO_STRICT, true),\n    ZEO_FIXED_TIME: process.env.ZEO_FIXED_TIME,\n    ZEO_WORKSPACE_ID: process.env.ZEO_WORKSPACE_ID?.trim() || \"default\",\n    PORT: process.env.PORT ? parseInt(process.env.PORT, 10) : undefined,\n\n    ZEO_LOG_REDACT: parseRedactMode(process.env.ZEO_LOG_REDACT),\n    ZEO_LOG_FORMAT: parseLogFormat(process.env.ZEO_LOG_FORMAT),\n\n    OPENAI_API_KEY: process.env.OPENAI_API_KEY,\n    ANTHROPIC_API_KEY: process.env.ANTHROPIC_API_KEY,\n    OPENROUTER_API_KEY: process.env.OPENROUTER_API_KEY,\n    SUPABASE_URL: process.env.SUPABASE_URL,\n    SUPABASE_SERVICE_KEY: process.env.SUPABASE_SERVICE_KEY,\n\n    ZEO_MODEL: process.env.ZEO_MODEL || \"gpt-4o-mini\",\n    ZEO_PROVIDER: process.env.ZEO_PROVIDER || \"openai\",\n    KEYS_MODEL: process.env.KEYS_MODEL || \"local-default\",\n    KEYS_PROVIDER: process.env.KEYS_PROVIDER || \"local\",\n    READYLAYER_MODEL: process.env.READYLAYER_MODEL || \"local-default\",\n    READYLAYER_PROVIDER: process.env.READYLAYER_PROVIDER || \"local\",\n    SETTLER_MODEL: process.env.SETTLER_MODEL || \"local-default\",\n    SETTLER_PROVIDER: process.env.SETTLER_PROVIDER || \"local\",\n\n    ZEO_SIGNING_HMAC_KEY: process.env.ZEO_SIGNING_HMAC_KEY,\n\n    GITHUB_TOKEN: process.env.GITHUB_TOKEN,\n    SLACK_WEBHOOK_URL: process.env.SLACK_WEBHOOK_URL,\n    ZEO_PLUGIN_PATH: process.env.ZEO_PLUGIN_PATH,\n\n    // LLM Configuration (optional, for llm-cli.ts)\n    ZEO_LLM_PROVIDER: process.env.ZEO_LLM_PROVIDER,\n    ZEO_LLM_MODEL: process.env.ZEO_LLM_MODEL,\n    ZEO_LLM_BASE_URL: process.env.ZEO_LLM_BASE_URL,\n    ZEO_LLM_API_KEY: process.env.ZEO_LLM_API_KEY,\n    ZEO_LLM_SEED: process.env.ZEO_LLM_SEED,\n  };\n\n  // Fail fast validations\n  if (process.env.PORT && isNaN(config.PORT as number)) {\n    throw new Error(\"PORT must be a valid number\");\n  }\n\n  cachedConfig = config;\n  return config;\n}\n\nexport function resetConfigCache() {\n  cachedConfig = null;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\core\\errors.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errorMessage' is defined but never used. Allowed unused args must match /^_/u.","line":133,"column":3,"messageId":"unusedVar","endLine":133,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Reach Core Error Types\n *\n * Standardized error types and utilities for consistent error handling\n * across the Reach codebase.\n */\n\n/** Standardized error codes for Reach operations */\nexport const ErrorCodes = {\n  // Success (0)\n  SUCCESS: 0,\n\n  // Generic failures (1-9)\n  GENERIC_FAILURE: 1,\n  INVALID_INPUT: 2,\n  NOT_FOUND: 3,\n  POLICY_BLOCKED: 4,\n  VERIFICATION_FAILED: 5,\n  CONFIG_INVALID: 6,\n  TIMEOUT: 7,\n  UNAVAILABLE: 8,\n\n  // LLM/Provider errors (10-19)\n  LLM_PROVIDER_UNREACHABLE: 10,\n  LLM_MODEL_UNAVAILABLE: 11,\n  LLM_NON_DETERMINISTIC: 12,\n  LLM_API_ERROR: 13,\n\n  // Replay errors (20-29)\n  REPLAY_DATASET_INVALID: 20,\n  REPLAY_CASE_FAILED: 21,\n  REPLAY_MISMATCH: 22,\n  REPLAY_BUDGET_EXCEEDED: 23,\n\n  // Determinism errors (30-39)\n  DETERMINISM_VIOLATION: 30,\n  HASH_MISMATCH: 31,\n\n  // IO/FS errors (40-49)\n  FILE_NOT_FOUND: 40,\n  FILE_READ_ERROR: 41,\n  FILE_WRITE_ERROR: 42,\n  PERMISSION_DENIED: 43,\n} as const;\n\nexport type ErrorCode = (typeof ErrorCodes)[keyof typeof ErrorCodes];\n\n/** Get human-readable description for an error code */\nexport function getErrorCodeDescription(code: ErrorCode): string {\n  const descriptions: Record<ErrorCode, string> = {\n    [ErrorCodes.SUCCESS]: \"Success\",\n    [ErrorCodes.GENERIC_FAILURE]: \"Generic failure\",\n    [ErrorCodes.INVALID_INPUT]: \"Invalid input or usage\",\n    [ErrorCodes.NOT_FOUND]: \"Resource not found\",\n    [ErrorCodes.POLICY_BLOCKED]: \"Operation blocked by policy\",\n    [ErrorCodes.VERIFICATION_FAILED]: \"Verification failed\",\n    [ErrorCodes.CONFIG_INVALID]: \"Invalid configuration\",\n    [ErrorCodes.TIMEOUT]: \"Operation timed out\",\n    [ErrorCodes.UNAVAILABLE]: \"Service unavailable\",\n    [ErrorCodes.LLM_PROVIDER_UNREACHABLE]: \"LLM provider unreachable\",\n    [ErrorCodes.LLM_MODEL_UNAVAILABLE]: \"LLM model unavailable\",\n    [ErrorCodes.LLM_NON_DETERMINISTIC]: \"Non-deterministic LLM configuration\",\n    [ErrorCodes.LLM_API_ERROR]: \"LLM API error\",\n    [ErrorCodes.REPLAY_DATASET_INVALID]: \"Invalid replay dataset\",\n    [ErrorCodes.REPLAY_CASE_FAILED]: \"Replay case failed\",\n    [ErrorCodes.REPLAY_MISMATCH]: \"Replay output mismatch\",\n    [ErrorCodes.REPLAY_BUDGET_EXCEEDED]: \"Replay budget exceeded\",\n    [ErrorCodes.DETERMINISM_VIOLATION]: \"Determinism violation detected\",\n    [ErrorCodes.HASH_MISMATCH]: \"Hash mismatch\",\n    [ErrorCodes.FILE_NOT_FOUND]: \"File not found\",\n    [ErrorCodes.FILE_READ_ERROR]: \"File read error\",\n    [ErrorCodes.FILE_WRITE_ERROR]: \"File write error\",\n    [ErrorCodes.PERMISSION_DENIED]: \"Permission denied\",\n  };\n  return descriptions[code] ?? `Unknown error code: ${code}`;\n}\n\n/** Structured error with code and context */\nexport class ReachError extends Error {\n  public readonly code: ErrorCode;\n  public readonly context?: Record<string, unknown>;\n  public readonly cause?: Error;\n\n  constructor(\n    code: ErrorCode,\n    message: string,\n    options?: { context?: Record<string, unknown>; cause?: Error },\n  ) {\n    super(message);\n    this.name = \"ReachError\";\n    this.code = code;\n    this.context = options?.context;\n    this.cause = options?.cause;\n  }\n\n  /** Format error for CLI output */\n  toCLIString(): string {\n    const parts = [`[ERROR ${this.code}] ${this.message}`];\n    if (this.context && Object.keys(this.context).length > 0) {\n      parts.push(`Context: ${JSON.stringify(this.context, null, 2)}`);\n    }\n    if (this.cause) {\n      parts.push(`Caused by: ${this.cause.message}`);\n    }\n    return parts.join(\"\\n\");\n  }\n}\n\n/** Ensure any thrown value is converted to a ReachError */\nexport function toReachError(\n  error: unknown,\n  defaultCode: ErrorCode = ErrorCodes.GENERIC_FAILURE,\n): ReachError {\n  if (error instanceof ReachError) return error;\n  if (error instanceof Error) {\n    return new ReachError(defaultCode, error.message, { cause: error });\n  }\n  return new ReachError(defaultCode, String(error));\n}\n\n/** Exit process with standardized error code */\nexport function exitWithError(code: ErrorCode, message?: string): never {\n  if (message) {\n    console.error(`[EXIT ${code}] ${message}`);\n  }\n  process.exit(code);\n}\n\n/** Safe wrapper for async operations that ensures no uncaught exceptions */\nexport async function safeRun<T>(\n  fn: () => Promise<T>,\n  errorCode: ErrorCode,\n  errorMessage: string,\n): Promise<T> {\n  try {\n    return await fn();\n  } catch (error) {\n    throw toReachError(error, errorCode);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\core\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\core\\node-syscall.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\core\\shim.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\core\\syscall.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\core\\syscall.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\core\\trust.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":19,"messageId":"unexpectedAny","endLine":34,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[918,921],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[918,921],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":19,"messageId":"unexpectedAny","endLine":60,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1810,1813],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1810,1813],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Command } from \"commander\";\nimport { resolve } from \"node:path\";\nimport { compactTrustProfiles, deriveTrustTier } from \"./shim.js\";\n\nexport const trust = new Command(\"trust\");\n\ntrust.description(\"Manage trust profiles and reputation\").action(() => {\n  trust.help();\n});\n\ntrust\n  .command(\"list\")\n  .description(\"List all trust profiles\")\n  .option(\"-d, --dir <path>\", \"Trust profile root directory\", \".\")\n  .action(async (opts) => {\n    const root = resolve(process.cwd(), opts.dir);\n    try {\n      const profiles = await compactTrustProfiles(root);\n\n      if (profiles.length === 0) {\n        console.log(\"No trust profiles found.\");\n        return;\n      }\n\n      console.table(\n        profiles.map((p) => ({\n          ID: p.subject_id,\n          Type: p.subject_type,\n          Tier: deriveTrustTier(p),\n          Pass: p.pass_count,\n          Fail: p.fail_count,\n        })),\n      );\n    } catch (err: any) {\n      console.error(\"Error listing trust profiles:\", err.message);\n      process.exit(1);\n    }\n  });\n\ntrust\n  .command(\"verify <subjectId>\")\n  .description(\"Check the trust tier of a specific subject\")\n  .option(\"-d, --dir <path>\", \"Trust profile root directory\", \".\")\n  .action(async (subjectId, opts) => {\n    const root = resolve(process.cwd(), opts.dir);\n    try {\n      const profiles = await compactTrustProfiles(root);\n      const profile = profiles.find((p) => p.subject_id === subjectId);\n\n      if (!profile) {\n        console.log(`Subject '${subjectId}' not found.`);\n        console.log(\"Tier: unknown\");\n        return;\n      }\n\n      const tier = deriveTrustTier(profile);\n      console.log(`Subject: ${profile.subject_id}`);\n      console.log(`Tier:    ${tier}`);\n      console.log(`Stats:   ${profile.pass_count} pass / ${profile.fail_count} fail`);\n    } catch (err: any) {\n      console.error(\"Error verifying subject:\", err.message);\n      process.exit(1);\n    }\n  });\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\core\\zeolite-core.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\core\\zeolite-core.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\determinism\\__tests__\\canonicalJson.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\determinism\\canonicalJson.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\determinism\\crossLanguageHash.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\determinism\\determinism-invariants.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\determinism\\deterministicCompare.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\determinism\\deterministicMap.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\determinism\\deterministicSort.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\determinism\\hashStream.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\determinism\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\determinism\\seededRandom.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\governance\\codegen.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\governance\\governance-hardening.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\governance\\nl-compiler.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\index.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":23,"messageId":"unexpectedAny","endLine":8,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[163,166],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[163,166],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import {\n  evaluateDecisionFallback,\n  type DecisionInput,\n  type DecisionOutput,\n} from \"./lib/fallback.js\";\n\nexport class DecisionEngine {\n  private wasmModule: any = null;\n  private initialized = false;\n\n  async init() {\n    if (this.initialized) return;\n    try {\n      // Use dynamic import for ESM compatibility and optional loading\n      // @ts-ignore - WASM module might not be built\n      this.wasmModule = await import(\"../pkg/decision_engine_rs.js\").catch(() => null);\n      if (!this.wasmModule) {\n        console.warn(\n          \"WARN: WASM module not found at '../pkg/decision_engine_rs.js'. Using fallback.\",\n        );\n      }\n    } catch (e) {\n      console.warn(\n        \"WARN: Failed to load WASM decision engine. Falling back to TS implementation.\",\n        e,\n      );\n    }\n    this.initialized = true;\n  }\n\n  evaluate(input: DecisionInput): DecisionOutput {\n    if (this.wasmModule && typeof this.wasmModule.evaluate_decision === \"function\") {\n      try {\n        const inputJson = JSON.stringify(input);\n        const outputJson = this.wasmModule.evaluate_decision(inputJson);\n        return JSON.parse(outputJson);\n      } catch (e) {\n        console.error(\"ERROR: WASM execution failed. Using fallback.\", e);\n      }\n    }\n    return evaluateDecisionFallback(input);\n  }\n}\n\n/**\n * Singleton instance for convenience, maintaining backwards compatibility\n * while allowing class-based instantiation for testing.\n */\nconst defaultEngine = new DecisionEngine();\n\nexport async function evaluateDecision(input: DecisionInput): Promise<DecisionOutput> {\n  await defaultEngine.init();\n  return defaultEngine.evaluate(input);\n}\n\nexport { type DecisionInput, type DecisionOutput };\n\n// Usage Example (for verification)\n/*\nconst input = {\n  actions: [\"a1\", \"a2\"],\n  states: [\"s1\", \"s2\"],\n  outcomes: { \"a1\": {\"s1\": 10, \"s2\": 5}, \"a2\": {\"s1\": 0, \"s2\": 20} }\n};\nconsole.log(evaluateDecision(input));\n*/\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\lib\\args.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\lib\\cta.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\lib\\dashboard-viewmodel.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\lib\\fallback.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":10,"messageId":"unexpectedAny","endLine":18,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[422,425],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[422,425],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TypeScript Fallback for Minimax Regret\n * Used if WASM fails to load.\n */\n\nexport interface DecisionInput {\n  actions: string[];\n  states: string[];\n  outcomes: Record<string, Record<string, number>>;\n  algorithm?: \"minimax_regret\" | \"maximin\" | \"weighted_sum\";\n  weights?: Record<string, number>;\n  strict?: boolean;\n}\n\nexport interface DecisionOutput {\n  recommended_action: string;\n  ranking: string[];\n  trace: any;\n}\n\nexport function evaluateDecisionFallback(input: DecisionInput): DecisionOutput {\n  // Handle weights normalization or validation\n  let effectiveWeights = input.weights;\n\n  if (input.weights) {\n    const sum = Object.values(input.weights).reduce((a, b) => a + b, 0);\n\n    if (input.strict) {\n      if (Math.abs(sum - 1.0) > 1e-9) {\n        throw new Error(`Weights must sum to 1.0 (got ${sum})`);\n      }\n    } else if (sum !== 0 && Math.abs(sum - 1.0) > 1e-9) {\n      // Normalize if not strict\n      effectiveWeights = {};\n      for (const [k, v] of Object.entries(input.weights)) {\n        effectiveWeights[k] = v / sum;\n      }\n    }\n  }\n\n  // Create effective input with potentially normalized weights\n  const effectiveInput = { ...input, weights: effectiveWeights };\n\n  if (input.algorithm === \"maximin\") {\n    return maximinFallback(effectiveInput);\n  }\n  if (input.algorithm === \"weighted_sum\") {\n    return weightedSumFallback(effectiveInput);\n  }\n\n  // 1. Max Utility per State\n  const maxStateUtil: Record<string, number> = {};\n  for (const state of effectiveInput.states) {\n    let max = -Infinity;\n    for (const action of effectiveInput.actions) {\n      const val = effectiveInput.outcomes[action]?.[state] ?? -Infinity;\n      if (val > max) max = val;\n    }\n    maxStateUtil[state] = max;\n  }\n\n  // 2. Regret Table\n  const regretTable: Record<string, Record<string, number>> = {};\n  const maxRegret: Record<string, number> = {};\n\n  for (const action of effectiveInput.actions) {\n    regretTable[action] = {};\n    let currentMax = 0;\n    for (const state of effectiveInput.states) {\n      const util = effectiveInput.outcomes[action]?.[state] ?? 0;\n      const regret = maxStateUtil[state] - util;\n      regretTable[action][state] = regret;\n      if (regret > currentMax) currentMax = regret;\n    }\n    maxRegret[action] = currentMax;\n  }\n\n  // 3. Ranking\n  const ranking = [...effectiveInput.actions].sort((a, b) => {\n    const diff = maxRegret[a] - maxRegret[b];\n    if (Math.abs(diff) < 1e-9) {\n      return a < b ? -1 : a > b ? 1 : 0; // Code-point comparison for deterministic tie-break\n    }\n    return diff;\n  });\n\n  return {\n    recommended_action: ranking[0],\n    ranking,\n    trace: {\n      algorithm: \"minimax_regret_fallback\",\n      max_regret: maxRegret,\n    },\n  };\n}\n\nfunction weightedSumFallback(input: DecisionInput): DecisionOutput {\n  const weights = input.weights || {};\n\n  // 1. Calculate Scores\n  const scores: Record<string, number> = {};\n\n  for (const action of input.actions) {\n    let score = 0;\n    for (const state of input.states) {\n      const util = input.outcomes[action]?.[state] ?? 0;\n      const weight = weights[state] ?? 0;\n      score += util * weight;\n    }\n    scores[action] = score;\n  }\n\n  // 2. Ranking\n  const ranking = [...input.actions].sort((a, b) => {\n    const sA = scores[a];\n    const sB = scores[b];\n    // Descending sort\n    if (Math.abs(sA - sB) < 1e-9) {\n      return a < b ? -1 : a > b ? 1 : 0; // Code-point comparison for deterministic tie-break\n    }\n    return sB - sA;\n  });\n\n  return {\n    recommended_action: ranking[0],\n    ranking,\n    trace: {\n      algorithm: \"weighted_sum\",\n      weighted_scores: scores,\n    },\n  };\n}\n\nfunction maximinFallback(input: DecisionInput): DecisionOutput {\n  // 1. Min Utility per Action\n  const minUtility: Record<string, number> = {};\n\n  for (const action of input.actions) {\n    let min = Infinity;\n    for (const state of input.states) {\n      const val = input.outcomes[action]?.[state] ?? -Infinity;\n      if (val < min) min = val;\n    }\n    minUtility[action] = min;\n  }\n\n  // 2. Ranking\n  const ranking = [...input.actions].sort((a, b) => {\n    const valA = minUtility[a];\n    const valB = minUtility[b];\n    // Descending sort for utility\n    if (Math.abs(valA - valB) < 1e-9) {\n      return a < b ? -1 : a > b ? 1 : 0; // Code-point comparison for deterministic tie-break\n    }\n    return valB - valA;\n  });\n\n  return {\n    recommended_action: ranking[0],\n    ranking,\n    trace: {\n      algorithm: \"maximin_fallback\",\n      min_utility: minUtility,\n    },\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\lib\\generateViewModel.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\lib\\llm-provider.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\lib\\llm-provider.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'LlmCli' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"messageId":"unusedVar","endLine":3,"endColumn":16,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"LlmCli"},"fix":{"range":[83,127],"text":""},"desc":"Remove unused import declaration."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import type { LlmConfig, LlmProviderName } from \"../cli/llm-cli.js\";\n// @ts-ignore\nimport { LlmCli } from \"../cli/llm-cli.js\";\n\nexport interface LlmMessage {\n  role: \"system\" | \"user\" | \"assistant\";\n  content: string;\n}\n\nexport interface LlmUsage {\n  inputTokens?: number;\n  outputTokens?: number;\n}\n\nexport interface LlmProvider {\n  chat(\n    messages: LlmMessage[],\n    jsonSchema?: Record<string, unknown>,\n    seed?: number,\n    temperature?: number,\n  ): Promise<{ json: unknown; usage: LlmUsage }>;\n}\n\nexport const SUPPORTED_PROVIDER_FIXTURE_NAMES = [\n  \"openai\",\n  \"anthropic\",\n  \"openrouter\",\n  \"ollama\",\n] as const;\n\ninterface RequestShape {\n  url: string;\n  headers: Record<string, string>;\n  body: Record<string, unknown>;\n}\n\ninterface ProviderResponse {\n  json: unknown;\n  usage: LlmUsage;\n}\n\nfunction validateDeterminism(seed: number, temperature: number): void {\n  if (!Number.isInteger(seed) || seed < 0) throw new Error(\"seed must be a non-negative integer\");\n  if (temperature !== 0) throw new Error(\"temperature must be 0 for deterministic mode\");\n}\n\nfunction normalizeBaseUrl(provider: LlmProviderName, baseUrl?: string): string {\n  if (baseUrl) return baseUrl;\n  if (provider === \"openai\") return \"https://api.openai.com/v1\";\n  if (provider === \"anthropic\") return \"https://api.anthropic.com/v1\";\n  if (provider === \"openrouter\") return \"https://openrouter.ai/api/v1\";\n  return \"http://127.0.0.1:11434\";\n}\n\nfunction asOpenAiMessages(messages: LlmMessage[]): Array<Record<string, string>> {\n  return messages.map((message) => ({\n    role: message.role,\n    content: message.content,\n  }));\n}\n\nfunction buildRequest(\n  provider: LlmProviderName,\n  config: LlmConfig,\n  messages: LlmMessage[],\n  jsonSchema: Record<string, unknown> | undefined,\n  seed: number,\n  temperature: number,\n): RequestShape {\n  const baseUrl = normalizeBaseUrl(provider, config.baseUrl);\n\n  if (provider === \"openai\") {\n    return {\n      url: `${baseUrl}/chat/completions`,\n      headers: {\n        \"content-type\": \"application/json\",\n        authorization: `Bearer ${config.apiKey}`,\n      },\n      body: {\n        model: config.model,\n        messages: asOpenAiMessages(messages),\n        temperature,\n        seed,\n        ...(jsonSchema\n          ? {\n              response_format: {\n                type: \"json_schema\",\n                json_schema: {\n                  name: \"zeo_schema\",\n                  strict: true,\n                  schema: jsonSchema,\n                },\n              },\n            }\n          : {}),\n      },\n    };\n  }\n\n  if (provider === \"anthropic\") {\n    const system = messages\n      .filter((m) => m.role === \"system\")\n      .map((m) => m.content)\n      .join(\"\\n\\n\");\n    const conversation = messages\n      .filter((m) => m.role !== \"system\")\n      .map((m) => ({ role: m.role, content: m.content }));\n    return {\n      url: `${baseUrl}/messages`,\n      headers: {\n        \"content-type\": \"application/json\",\n        \"x-api-key\": config.apiKey ?? \"\",\n        \"anthropic-version\": \"2023-06-01\",\n      },\n      body: {\n        model: config.model,\n        temperature,\n        messages: conversation,\n        system,\n        max_tokens: 1024,\n      },\n    };\n  }\n\n  if (provider === \"openrouter\") {\n    return {\n      url: `${baseUrl}/chat/completions`,\n      headers: {\n        \"content-type\": \"application/json\",\n        authorization: `Bearer ${config.apiKey}`,\n      },\n      body: {\n        model: config.model,\n        messages: asOpenAiMessages(messages),\n        temperature,\n        seed,\n        response_format: jsonSchema ? { type: \"json_object\" } : undefined,\n      },\n    };\n  }\n\n  return {\n    url: `${baseUrl}/api/chat`,\n    headers: {\n      \"content-type\": \"application/json\",\n    },\n    body: {\n      model: config.model,\n      stream: false,\n      messages: asOpenAiMessages(messages),\n      format: jsonSchema ?? undefined,\n      options: { temperature, seed },\n    },\n  };\n}\n\nfunction tryParseJsonObject(raw: string, provider: LlmProviderName): unknown {\n  try {\n    return JSON.parse(raw);\n  } catch {\n    throw new Error(`Provider '${provider}' returned non-JSON content`);\n  }\n}\n\nfunction parseProviderResponse(\n  provider: LlmProviderName,\n  payload: Record<string, unknown>,\n): ProviderResponse {\n  if (provider === \"openai\" || provider === \"openrouter\") {\n    const choices = Array.isArray(payload.choices) ? payload.choices : [];\n    const first = choices[0] as Record<string, unknown> | undefined;\n    const message = (first?.message ?? {}) as Record<string, unknown>;\n    const content = message.content;\n    if (typeof content !== \"string\" || content.trim().length === 0) {\n      throw new Error(`Malformed ${provider} response: missing choices[0].message.content`);\n    }\n    return {\n      json: tryParseJsonObject(content, provider),\n      usage: {\n        inputTokens:\n          typeof (payload.usage as Record<string, unknown> | undefined)?.prompt_tokens === \"number\"\n            ? (payload.usage as Record<string, number>).prompt_tokens\n            : undefined,\n        outputTokens:\n          typeof (payload.usage as Record<string, unknown> | undefined)?.completion_tokens ===\n          \"number\"\n            ? (payload.usage as Record<string, number>).completion_tokens\n            : undefined,\n      },\n    };\n  }\n\n  if (provider === \"anthropic\") {\n    const content = Array.isArray(payload.content) ? payload.content : [];\n    const first = content[0] as Record<string, unknown> | undefined;\n    const text = typeof first?.text === \"string\" ? first.text : \"\";\n    if (!text.trim()) {\n      throw new Error(\"Malformed anthropic response: missing content[0].text\");\n    }\n    return {\n      json: tryParseJsonObject(text, provider),\n      usage: {\n        inputTokens:\n          typeof (payload.usage as Record<string, unknown> | undefined)?.input_tokens === \"number\"\n            ? (payload.usage as Record<string, number>).input_tokens\n            : undefined,\n        outputTokens:\n          typeof (payload.usage as Record<string, unknown> | undefined)?.output_tokens === \"number\"\n            ? (payload.usage as Record<string, number>).output_tokens\n            : undefined,\n      },\n    };\n  }\n\n  const message = (payload.message ?? {}) as Record<string, unknown>;\n  const content = message.content;\n  if (typeof content !== \"string\" || content.trim().length === 0) {\n    throw new Error(\"Malformed ollama response: missing message.content\");\n  }\n  return {\n    json: tryParseJsonObject(content, provider),\n    usage: {\n      inputTokens:\n        typeof payload.prompt_eval_count === \"number\"\n          ? (payload.prompt_eval_count as number)\n          : undefined,\n      outputTokens:\n        typeof payload.eval_count === \"number\" ? (payload.eval_count as number) : undefined,\n    },\n  };\n}\n\nfunction schemaType(value: unknown): string {\n  if (Array.isArray(value)) return \"array\";\n  if (value === null) return \"null\";\n  return typeof value;\n}\n\nfunction validateSchemaValue(value: unknown, schema: Record<string, unknown>, path: string): void {\n  const expected = schema.type;\n  if (typeof expected === \"string\") {\n    if (expected === \"object\") {\n      if (!value || typeof value !== \"object\" || Array.isArray(value)) {\n        throw new Error(\n          `Schema validation failed at ${path}: expected object, received ${schemaType(value)}`,\n        );\n      }\n      const required = Array.isArray(schema.required) ? schema.required.map(String) : [];\n      const properties = (schema.properties ?? {}) as Record<string, Record<string, unknown>>;\n      for (const req of required) {\n        if (!(req in (value as Record<string, unknown>))) {\n          throw new Error(\n            `Schema validation failed at ${path}: missing required property '${req}'`,\n          );\n        }\n      }\n      for (const [key, nestedSchema] of Object.entries(properties)) {\n        if (key in (value as Record<string, unknown>)) {\n          validateSchemaValue(\n            (value as Record<string, unknown>)[key],\n            nestedSchema,\n            `${path}.${key}`,\n          );\n        }\n      }\n      return;\n    }\n\n    if (expected === \"array\") {\n      if (!Array.isArray(value))\n        throw new Error(\n          `Schema validation failed at ${path}: expected array, received ${schemaType(value)}`,\n        );\n      const itemSchema = (schema.items ?? {}) as Record<string, unknown>;\n      if (Object.keys(itemSchema).length > 0) {\n        value.forEach((item, idx) => validateSchemaValue(item, itemSchema, `${path}[${idx}]`));\n      }\n      return;\n    }\n\n    if (expected !== schemaType(value)) {\n      throw new Error(\n        `Schema validation failed at ${path}: expected ${expected}, received ${schemaType(value)}`,\n      );\n    }\n  }\n}\n\nexport function validateJsonSchema(value: unknown, schema?: Record<string, unknown>): void {\n  if (!schema) return;\n  validateSchemaValue(value, schema, \"$\");\n}\n\nexport function createProvider(config: LlmConfig): LlmProvider {\n  return {\n    async chat(messages, jsonSchema, seed = config.seed, temperature = 0) {\n      validateDeterminism(seed, temperature);\n      const provider = config.provider === \"custom\" ? \"ollama\" : config.provider;\n      const req = buildRequest(provider, config, messages, jsonSchema, seed, temperature);\n      const response = await fetch(req.url, {\n        method: \"POST\",\n        headers: req.headers,\n        body: JSON.stringify(req.body),\n      });\n      if (!response.ok) {\n        const detail = await response.text();\n        throw new Error(`Provider request failed with status ${response.status}: ${detail}`);\n      }\n      const payload = (await response.json()) as Record<string, unknown>;\n      const parsed = parseProviderResponse(provider, payload);\n      validateJsonSchema(parsed.json, jsonSchema);\n      return parsed;\n    },\n  };\n}\n\nexport const __internal = {\n  buildRequest,\n  parseProviderResponse,\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\lib\\observability.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\lib\\validate-import-boundaries.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\scott\\Documents\\GitHub\\Reach\\src\\lib\\validate-oss-purity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]