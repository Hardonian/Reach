package mcpserver

import (
	"context"
	"errors"
	"fmt"
	"io/fs"
	"os"
	"path/filepath"
	"strings"
	"sync/atomic"

	"github.com/modelcontextprotocol/go-sdk/mcp"

	policygate "reach/services/runner/internal/policy"
	"reach/services/runner/internal/sandbox"
)

const CapabilityFilesystemWrite = "filesystem:write"

var (
	ErrToolNotFound      = errors.New("tool not found")
	ErrCapabilityDenied  = errors.New("capability denied")
	ErrConnectorDisabled = errors.New("connector disabled")
	ErrScopeDenied       = errors.New("scope denied")
	ErrPolicyDenied      = errors.New("policy denied")
	ErrApprovalRequired  = errors.New("approval required")
)

type Policy interface {
	Allowed(runID, capability string) bool
	ProfileAllowed(profile, capability string) bool
}

type ConnectorResolver interface {
	Resolve(runID, tool string) (ConnectorContext, error)
}

type ApprovalGate interface {
	Required(runID, tool string) bool
}

type ConnectorContext struct {
	Enabled           bool
	Scopes            []string
	Capabilities      []string
	LegacyUnsigned    bool
	Policy            string
	PolicyVersion     string
	TemplatePolicy    string
	ManifestID        string
	ManifestVersion   string
	ManifestHash      string
	ModelRequirements map[string]string
	Deterministic     bool
	CachedValidated   bool
}

type AuditLogger interface {
	LogToolInvocation(ctx context.Context, entry AuditEntry)
	LogAuditEvent(ctx context.Context, entry DeterministicAuditEvent)
}

type AuditEntry struct {
	RunID        string
	Tool         string
	Input        map[string]any
	Success      bool
	Error        string
	Timestamp    int64 // Unix timestamp for determinism (avoids time.Time serialization issues)
	Capabilities []string
}

type DeterministicAuditEvent struct {
	Sequence            uint64
	EventType           string
	RunID               string
	PackID              string
	PackVersion         string
	PackHash            string
	NodeID              string
	OrgID               string
	PolicyVersion       string
	ContextSnapshotHash string
	Timestamp           int64 // Unix timestamp for determinism
	Decision            string
	Reasons             []string
}

// Server provides the MCP server with policy enforcement and sandboxing.
type Server struct {
	workspaceRoot       string
	policy              Policy
	audit               AuditLogger
	mcpServer           *mcp.Server
	connectors          ConnectorResolver
	approvalGate        ApprovalGate
	validated           map[string]string
	auditSequence       atomic.Uint64
	policyMode          policygate.Mode
	allowLegacyUnsigned bool

	// sandbox is the single enforcement layer for all capability checks
	sandbox *sandbox.EnforcementLayer
}

// New creates a new Server with the given configuration.
// It initializes the sandbox enforcement layer and registers tools.
func New(workspaceRoot string, policy Policy, audit AuditLogger, resolver ConnectorResolver, approval ApprovalGate) *Server {
	s := &Server{
		workspaceRoot:       workspaceRoot,
		policy:              policy,
		audit:               audit,
		mcpServer:           mcp.NewServer(mcp.WithName("reach-runner"), mcp.WithVersion("0.1.0")),
		connectors:          resolver,
		approvalGate:        approval,
		validated:           map[string]string{},
		policyMode:          policygate.ModeFromEnv(),
		allowLegacyUnsigned: policygate.AllowLegacyUnsignedFromEnv(),
		sandbox:             sandbox.NewEnforcementLayer(workspaceRoot),
	}
	s.registerTools()
	return s
}

func (s *Server) MCP() *mcp.Server { return s.mcpServer }

func (s *Server) registerTools() {
	s.mcpServer.AddTool(mcp.Tool{Name: "tool.echo", Description: "Echoes the input text"}, s.callEcho)
	s.mcpServer.AddTool(mcp.Tool{Name: "tool.read_file", Description: "Reads a UTF-8 file from workspace"}, s.callReadFile)
	s.mcpServer.AddTool(mcp.Tool{Name: "tool.write_file", Description: "Writes UTF-8 content to a workspace file"}, s.callWriteFile)
	s.mcpServer.AddTool(mcp.Tool{Name: "tool.summarize", Description: "Provides a concise summary of text"}, s.callSummarize)
}

func (s *Server) callSummarize(_ context.Context, _ string, input map[string]any) (any, error) {
	// Simulated summarize for now
	return map[string]any{"summary": "This is a deterministic summary generated by the Reach core engine."}, nil
}

// CallTool invokes a tool with policy enforcement and sandboxing.
// This is the main entry point for tool execution and all access flows through here.
func (s *Server) CallTool(ctx context.Context, runID, tool string, input map[string]any) (any, error) {
	s.logDeterministic(ctx, DeterministicAuditEvent{EventType: "execution.started", RunID: runID, Timestamp: 0})

	if capErr := s.checkFirewall(runID, tool); capErr != nil {
		s.audit.LogToolInvocation(ctx, AuditEntry{RunID: runID, Tool: tool, Input: input, Timestamp: 0, Error: capErr.Error(), Capabilities: requiredCapabilities(tool)})
		s.logDeterministic(ctx, DeterministicAuditEvent{EventType: "execution.failed", RunID: runID, Timestamp: 0, Reasons: []string{capErr.Error()}})
		return nil, capErr
	}

	result, err := s.mcpServer.CallTool(ctx, tool, input, runID)
	entry := AuditEntry{RunID: runID, Tool: tool, Input: input, Timestamp: 0, Success: err == nil, Capabilities: requiredCapabilities(tool)}
	if err != nil {
		entry.Error = err.Error()
		s.logDeterministic(ctx, DeterministicAuditEvent{EventType: "execution.failed", RunID: runID, Timestamp: 0, Reasons: []string{err.Error()}})
	} else {
		s.logDeterministic(ctx, DeterministicAuditEvent{EventType: "execution.completed", RunID: runID, Timestamp: 0})
	}
	s.audit.LogToolInvocation(ctx, entry)
	return result, err
}

func requiredCapabilities(tool string) []string {
	if tool == "tool.write_file" {
		return []string{CapabilityFilesystemWrite}
	}
	return nil
}

func requiredScopes(tool string) []string {
	if tool == "tool.write_file" {
		return []string{"workspace:write"}
	}
	return []string{"workspace:read"}
}

// checkFirewall performs policy and capability checks before tool execution.
// All enforcement flows through this single layer - no bypass is possible.
func (s *Server) checkFirewall(runID, tool string) error {
	if s.connectors != nil {
		ctx, err := s.connectors.Resolve(runID, tool)
		if err != nil {
			return err
		}
		if !ctx.Enabled {
			return ErrConnectorDisabled
		}
		if ctx.TemplatePolicy != "" && ctx.Policy != ctx.TemplatePolicy {
			return fmt.Errorf("%w: rule_id=policy-template-mismatch connector_policy=%s template_policy=%s manifest=%s@%s", ErrPolicyDenied, ctx.Policy, ctx.TemplatePolicy, ctx.ManifestID, ctx.ManifestVersion)
		}
		if ctx.ManifestID != "" {
			cacheKey := ctx.ManifestID + "@" + ctx.ManifestVersion
			if existing, ok := s.validated[cacheKey]; ok && existing != ctx.ManifestHash {
				return fmt.Errorf("%w: rule_id=manifest-hash-changed manifest=%s hash=%s", ErrPolicyDenied, cacheKey, ctx.ManifestHash)
			}
			if ctx.CachedValidated {
				s.validated[cacheKey] = ctx.ManifestHash
			}
		}
		for _, scope := range requiredScopes(tool) {
			if !has(ctx.Scopes, scope) {
				return fmt.Errorf("%w: rule_id=scope-required scope=%s manifest=%s@%s", ErrScopeDenied, scope, ctx.ManifestID, ctx.ManifestVersion)
			}
		}
		for _, capability := range requiredCapabilities(tool) {
			if !has(ctx.Capabilities, capability) {
				return fmt.Errorf("%w: rule_id=capability-not-declared capability=%s manifest=%s@%s", ErrCapabilityDenied, capability, ctx.ManifestID, ctx.ManifestVersion)
			}
			if !s.policy.Allowed(runID, capability) || !s.policy.ProfileAllowed(ctx.Policy, capability) {
				return fmt.Errorf("%w: rule_id=policy-profile capability=%s manifest=%s@%s", ErrPolicyDenied, capability, ctx.ManifestID, ctx.ManifestVersion)
			}
		}

		decision := policygate.Evaluate(policygate.Input{
			Policy: policygate.OrgPolicy{
				Version:              ctx.PolicyVersion,
				AllowedPermissions:   ctx.Scopes,
				AllowedModels:        map[string][]string{"tier": []string{"standard", "high"}, "provider": []string{"openai", "anthropic"}},
				AllowLegacyUnsigned:  s.allowLegacyUnsigned,
				RequireDeterministic: false,
			},
			Node: policygate.NodeIdentity{NodeID: runID, OrgID: ctx.Policy},
			Pack: policygate.ExecutionPack{
				ID:                  ctx.ManifestID,
				Version:             ctx.ManifestVersion,
				Hash:                ctx.ManifestHash,
				DeclaredTools:       []string{tool},
				DeclaredPermissions: ctx.Scopes,
				ModelRequirements:   ctx.ModelRequirements,
				Deterministic:       ctx.Deterministic,
				Signed:              ctx.ManifestHash != "",
				LegacyUnsigned:      ctx.LegacyUnsigned,
			},
			RequestedTools:       []string{tool},
			RequestedPermissions: requiredScopes(tool),
			Mode:                 s.policyMode,
		})
		if decision.Allowed {
			s.logDeterministic(context.Background(), DeterministicAuditEvent{EventType: "pack.admitted", RunID: runID, PackID: ctx.ManifestID, PackVersion: ctx.ManifestVersion, PackHash: ctx.ManifestHash, PolicyVersion: ctx.PolicyVersion, Timestamp: 0, Decision: "allow"})
		} else {
			reasons := make([]string, 0, len(decision.Reasons))
			for _, reason := range decision.Reasons {
				reasons = append(reasons, reason.String())
			}
			s.logDeterministic(context.Background(), DeterministicAuditEvent{EventType: "pack.denied", RunID: runID, PackID: ctx.ManifestID, PackVersion: ctx.ManifestVersion, PackHash: ctx.ManifestHash, PolicyVersion: ctx.PolicyVersion, Timestamp: 0, Decision: "deny", Reasons: reasons})
			if s.policyMode == policygate.ModeEnforce {
				return fmt.Errorf("%w: %s", ErrPolicyDenied, strings.Join(reasons, ","))
			}
		}
	}
	if s.approvalGate != nil && s.approvalGate.Required(runID, tool) {
		return ErrApprovalRequired
	}
	return nil
}

func (s *Server) logDeterministic(ctx context.Context, event DeterministicAuditEvent) {
	event.Sequence = s.auditSequence.Add(1)
	s.audit.LogAuditEvent(ctx, event)
}

func has(items []string, needle string) bool {
	for _, item := range items {
		if item == needle {
			return true
		}
	}
	return false
}

func (s *Server) callEcho(_ context.Context, _ string, input map[string]any) (any, error) {
	text, _ := input["text"].(string)
	return map[string]any{"text": text}, nil
}

func (s *Server) callReadFile(_ context.Context, _ string, input map[string]any) (any, error) {
	path, _ := input["path"].(string)
	fullPath, err := s.resolveWorkspacePath(path)
	if err != nil {
		return nil, err
	}

	content, err := os.ReadFile(fullPath)
	if err != nil {
		if errors.Is(err, fs.ErrNotExist) {
			return nil, fmt.Errorf("file not found: %s", path)
		}
		return nil, err
	}
	return map[string]any{"path": path, "content": string(content)}, nil
}

func (s *Server) callWriteFile(_ context.Context, _ string, input map[string]any) (any, error) {
	path, _ := input["path"].(string)
	content, _ := input["content"].(string)
	fullPath, err := s.resolveWorkspacePath(path)
	if err != nil {
		return nil, err
	}

	if err := os.MkdirAll(filepath.Dir(fullPath), 0o755); err != nil {
		return nil, err
	}
	if err := os.WriteFile(fullPath, []byte(content), 0o644); err != nil {
		return nil, err
	}
	return map[string]any{"path": path, "bytes_written": len(content)}, nil
}

func (s *Server) resolveWorkspacePath(path string) (string, error) {
	if strings.TrimSpace(path) == "" {
		return "", errors.New("path is required")
	}
	clean := filepath.Clean(path)
	fullPath := filepath.Join(s.workspaceRoot, clean)
	rel, err := filepath.Rel(s.workspaceRoot, fullPath)
	if err != nil {
		return "", err
	}
	if rel == ".." || strings.HasPrefix(rel, ".."+string(filepath.Separator)) {
		return "", fmt.Errorf("path escapes workspace: %s", path)
	}
	return fullPath, nil
}
