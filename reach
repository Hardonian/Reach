#!/usr/bin/env bash
# cspell:ignore reachctl
set -euo pipefail

SELF_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
IN_REPO_LAYOUT=false
if [ -d "$SELF_DIR/services/runner" ]; then
  IN_REPO_LAYOUT=true
fi

find_reachctl() {
  if [ "$IN_REPO_LAYOUT" = true ] && [ -x "$SELF_DIR/services/runner/reachctl" ]; then
    echo "$SELF_DIR/services/runner/reachctl"
    return 0
  fi
  if command -v reachctl >/dev/null 2>&1; then
    command -v reachctl
    return 0
  fi
  if [ -x "$SELF_DIR/reachctl" ]; then
    echo "$SELF_DIR/reachctl"
    return 0
  fi
  if [ -x "$SELF_DIR/reachctl.exe" ]; then
    echo "$SELF_DIR/reachctl.exe"
    return 0
  fi
  return 1
}

run_reachctl() {
  local reachctl_bin
  if [ "$IN_REPO_LAYOUT" = true ] && [ -x "$SELF_DIR/services/runner/reachctl" ]; then
    (cd "$SELF_DIR/services/runner" && ./reachctl "$@")
    return 0
  fi

  if [ "$IN_REPO_LAYOUT" = true ] && [ -f "$SELF_DIR/services/runner/cmd/reachctl/main.go" ] && command -v go >/dev/null 2>&1; then
    local build_dir="${REACH_BUILD_DIR:-$SELF_DIR/build}"
    local fallback_bin="${build_dir}/reachctl"
    mkdir -p "$build_dir"
    if [ ! -x "$fallback_bin" ] || [ "$SELF_DIR/services/runner/cmd/reachctl/main.go" -nt "$fallback_bin" ]; then
      (cd "$SELF_DIR/services/runner" && go build -o "$fallback_bin" ./cmd/reachctl)
    fi
    "$fallback_bin" "$@"
    return 0
  fi

  if ! reachctl_bin="$(find_reachctl)"; then
    echo "error: reachctl not found in PATH." >&2
    echo "Install from releases or run from the repository root." >&2
    exit 1
  fi
  "$reachctl_bin" "$@"
}

latest_run_id_from_data_dir() {
  local data_dir="${REACH_DATA_DIR:-data}"
  local latest_file
  latest_file="$(ls -1t "${data_dir}"/runs/*.json 2>/dev/null | head -n 1 || true)"
  if [ -z "$latest_file" ]; then
    return 1
  fi
  basename "$latest_file" .json
}

run_demo_smoke_fallback() {
  local data_dir="${REACH_DATA_DIR:-data}"
  local wizard_json
  wizard_json="$(run_reachctl wizard --quick --json)"
  local run_id
  run_id="$(printf '%s\n' "$wizard_json" | sed -n 's/.*"run_id"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n 1)"
  local capsule_path
  capsule_path="$(printf '%s\n' "$wizard_json" | sed -n 's/.*"capsule_path"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n 1)"
  capsule_path="${capsule_path//\\//}"

  if [ -z "$run_id" ]; then
    if ! run_id="$(latest_run_id_from_data_dir)"; then
      echo "error: could not locate latest run in ${data_dir}/runs" >&2
      return 1
    fi
  fi
  if [ -z "$capsule_path" ]; then
    capsule_path="${data_dir}/capsules/${run_id}.capsule.json"
  fi

  # Ensure the capsule exists for replay verification.
  run_reachctl capsule create "$run_id" >/dev/null
  if [ ! -f "$capsule_path" ]; then
    capsule_path="${data_dir}/capsules/${run_id}.capsule.json"
  fi

  run_reachctl capsule verify "$capsule_path" >/dev/null
  run_reachctl capsule replay "$capsule_path" >/dev/null

  # Prefer a canonical local path for display when available.
  if [ -f "${data_dir}/capsules/${run_id}.capsule.json" ]; then
    capsule_path="${data_dir}/capsules/${run_id}.capsule.json"
  fi

  echo "Demo smoke completed."
  echo "Run ID: ${run_id}"
  echo "Capsule: ${capsule_path}"
  echo "Verified: true"
  echo "Replay Verified: true"
}

run_bugreport_fallback() {
  local output=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
      --output)
        shift
        output="${1:-}"
        ;;
    esac
    shift || true
  done

  local data_dir="${REACH_DATA_DIR:-data}"
  local stamp
  stamp="$(date -u +%Y%m%dT%H%M%SZ)"
  if [ -z "$output" ]; then
    output="${data_dir}/bugreports/reach-bugreport-${stamp}.zip"
  fi
  mkdir -p "$(dirname "$output")"

  local tmp_dir
  tmp_dir="$(mktemp -d)"
  trap 'rm -rf "$tmp_dir"' RETURN

  if run_reachctl version >"${tmp_dir}/version.txt" 2>&1; then
    :
  else
    echo "version unavailable" >"${tmp_dir}/version.txt"
  fi

  local run_id
  local doctor_exit=0
  if run_reachctl doctor >"${tmp_dir}/doctor.stdout.txt" 2>"${tmp_dir}/doctor.stderr.txt"; then
    doctor_exit=0
  else
    doctor_exit=$?
  fi

  {
    echo "{"
    echo "  \"generated_at\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\","
    echo "  \"docs_url\": \"https://reach-cli.com/docs/troubleshooting\","
    echo "  \"issue_template_url\": \"https://github.com/reach/reach/issues/new?template=bug_report.yml\","
    echo "  \"doctor_exit_code\": ${doctor_exit}"
    echo "}"
  } >"${tmp_dir}/metadata.json"

  {
    echo "{"
    local first=true
    while IFS='=' read -r key value; do
      case "$key" in
        REACH_*|NEXT_PUBLIC_*|GITHUB_*|STRIPE_*|READYLAYER_*|NODE_ENV|BILLING_ENABLED)
          local redacted="$value"
          local lower_key="${key,,}"
          if [[ "$lower_key" == *secret* || "$lower_key" == *token* || "$lower_key" == *key* || "$lower_key" == *password* || "$lower_key" == *cookie* || "$lower_key" == *private* ]]; then
            if [ -n "$value" ]; then
              redacted="[REDACTED]"
            fi
          fi
          if [ "$first" = true ]; then
            first=false
          else
            echo ","
          fi
          printf "  \"%s\": \"%s\"" "$key" "$(printf '%s' "$redacted" | sed 's/\\/\\\\/g; s/\"/\\\"/g')"
          ;;
      esac
    done < <(env | sort)
    echo
    echo "}"
  } >"${tmp_dir}/env-summary.json"

  if command -v python3 >/dev/null 2>&1; then
    python3 - "$tmp_dir" "$output" <<'PY'
import os
import sys
import zipfile

src, dst = sys.argv[1], sys.argv[2]
with zipfile.ZipFile(dst, "w", zipfile.ZIP_DEFLATED) as zf:
    for name in sorted(os.listdir(src)):
        zf.write(os.path.join(src, name), arcname=name)
PY
  else
    echo "error: python3 is required to create bugreport zip in fallback mode" >&2
    return 1
  fi

  echo "{"
  echo "  \"bugreport\": \"${output}\","
  echo "  \"doctor_exit_code\": ${doctor_exit}"
  echo "}"
}

print_help() {
  echo "Reach - Deterministic Execution Fabric"
  echo ""
  echo "QUICK START"
  echo "  reach doctor               Check system health"
  echo "  reach version              Show version information"
  echo "  reach demo                 One-command demo (run, verify, replay, capsule)"
  echo "  reach quickstart           Golden-path fixture or live quickstart artifacts"
  echo "  reach status               Component health + reconciliation status"
  echo "  reach bugreport            Collect redacted diagnostics"
  echo ""
  echo "CORE COMMANDS"
  echo "  doctor|version|run|proof|capsule|packs|wizard|gate|demo|quickstart|status|bugreport"
  echo ""
  echo "DOCUMENTATION"
  echo "  https://reach-cli.com"
}

cmd="${1:-help}"
case "$cmd" in
  doctor)
    shift
    if [ "$IN_REPO_LAYOUT" = true ]; then
      if [ -f "$SELF_DIR/build/doctor" ]; then
        "$SELF_DIR/build/doctor" "$@"
      elif [ -f "$SELF_DIR/tools/doctor/doctor" ]; then
        (cd "$SELF_DIR/tools/doctor" && ./doctor "$@" )
      elif [ -f "$SELF_DIR/tools/doctor/doctor.exe" ]; then
        (cd "$SELF_DIR/tools/doctor" && ./doctor.exe "$@" )
      else
        echo "Warning: Running via 'go run' (slow). Run 'make build' for faster starts." >&2
        (cd "$SELF_DIR/tools/doctor" && go run . "$@")
      fi
    else
      run_reachctl doctor "$@"
    fi
    ;;
  audit)
    shift
    if [ "$IN_REPO_LAYOUT" = true ]; then
      if [ -f "$SELF_DIR/build/reach-audit" ]; then
        "$SELF_DIR/build/reach-audit" "$@"
      elif [ -f "$SELF_DIR/tools/reach-audit/reach-audit" ]; then
        (cd "$SELF_DIR/tools/reach-audit" && ./reach-audit "$@" )
      elif [ -f "$SELF_DIR/tools/reach-audit/reach-audit.exe" ]; then
        (cd "$SELF_DIR/tools/reach-audit" && ./reach-audit.exe "$@" )
      else
        echo "Warning: Running via 'go run' (slow). Run 'make build' for faster starts." >&2
        (cd "$SELF_DIR/tools/reach-audit" && go run . "$@")
      fi
    else
      run_reachctl audit "$@"
    fi
    ;;
  eval)
    shift
    if [ "$IN_REPO_LAYOUT" = true ]; then
      if [ -f "$SELF_DIR/build/reach-eval" ]; then
        "$SELF_DIR/build/reach-eval" "$@"
      elif [ -f "$SELF_DIR/tools/reach-eval/reach-eval" ]; then
        (cd "$SELF_DIR/tools/reach-eval" && ./reach-eval "$@" )
      elif [ -f "$SELF_DIR/tools/reach-eval/reach-eval.exe" ]; then
        (cd "$SELF_DIR/tools/reach-eval" && ./reach-eval.exe "$@" )
      else
        echo "Warning: Running via 'go run' (slow). Run 'make build' for faster starts." >&2
        (cd "$SELF_DIR/tools/reach-eval" && go run . "$@")
      fi
    else
      run_reachctl eval "$@"
    fi
    ;;
  release-check)
    shift
    if [ "$IN_REPO_LAYOUT" = true ] && [ -f "$SELF_DIR/tools/release-check.sh" ]; then
      "$SELF_DIR/tools/release-check.sh" "$@"
    else
      echo "error: release-check is only available from a source checkout." >&2
      exit 2
    fi
    ;;
  report)
    shift
    subcmd="${1:-}"
    case "$subcmd" in
      demo)
        shift
        if [ "$IN_REPO_LAYOUT" = true ]; then
          (cd "$SELF_DIR" && node --import tsx/esm scripts/report/generate-demo-report.ts "$@")
        else
          run_reachctl demo report "$@"
        fi
        ;;
      verify)
        shift
        if [ "$IN_REPO_LAYOUT" = true ]; then
          (cd "$SELF_DIR" && node --import tsx/esm scripts/report/verify-report.ts "$@")
        else
          echo "error: 'reach report verify' requires a source checkout. Use 'reachctl artifact verify <bundle.zip>'." >&2
          exit 2
        fi
        ;;
      *)
        echo "usage: reach report demo|verify" >&2
        exit 2
        ;;
    esac
    ;;
  cost)
    shift
    if [ "$IN_REPO_LAYOUT" = true ]; then
      (cd "$SELF_DIR/tools/economics" && npm install --silent && npm start --silent -- report "$@")
    else
      echo "error: cost command is only available from a source checkout." >&2
      exit 2
    fi
    ;;
  metrics)
    shift
    if [ "$IN_REPO_LAYOUT" = true ]; then
      case "${1:-}" in
        gtm) shift; (cd "$SELF_DIR/tools/economics" && npm install --silent && npm start --silent -- metrics "$@") ;;
        *) (cd "$SELF_DIR/tools/economics" && npm install --silent && npm start --silent -- metrics "$@") ;;
      esac
    else
      echo "error: metrics command is only available from a source checkout." >&2
      exit 2
    fi
    ;;
  demo)
    shift
    if [ "$#" -eq 0 ]; then
      demo_tmp="$(mktemp)"
      demo_err_tmp="$(mktemp)"
      if run_reachctl demo smoke >"$demo_tmp" 2>"$demo_err_tmp"; then
        cat "$demo_tmp"
        [ -s "$demo_err_tmp" ] && cat "$demo_err_tmp" >&2 || true
        rm -f "$demo_tmp" "$demo_err_tmp"
      else
        rm -f "$demo_tmp" "$demo_err_tmp"
        run_demo_smoke_fallback
      fi
    else
      run_reachctl demo "$@"
    fi
    ;;
  quickstart)
    shift
    demo_output="$(mktemp)"
    demo_error="$(mktemp)"
    fixture_mode=true
    if run_reachctl demo smoke >"$demo_output" 2>"$demo_error"; then
      fixture_mode=false
      cat "$demo_output"
      [ -s "$demo_error" ] && cat "$demo_error" >&2 || true
    else
      run_demo_smoke_fallback >"$demo_output"
      cat "$demo_output"
    fi

    run_id="$(sed -n 's/^Run ID:[[:space:]]*//p' "$demo_output" | head -n 1)"
    if [ -z "${run_id}" ]; then
      run_id="fixture-run-0001"
    fi

    quickstart_args=(--run-id "$run_id")
    if [ "$fixture_mode" = true ]; then
      quickstart_args+=(--fixture-mode)
    fi
    if [ "$IN_REPO_LAYOUT" = true ] && [ -f "$SELF_DIR/scripts/quickstart-demo.mjs" ]; then
      node "$SELF_DIR/scripts/quickstart-demo.mjs" "${quickstart_args[@]}"
    else
      echo "Quickstart artifacts unavailable outside source checkout."
    fi

    rm -f "$demo_output" "$demo_error"
    ;;
  status)
    shift
    if [ "$IN_REPO_LAYOUT" = true ] && [ -f "$SELF_DIR/scripts/reach-status.mjs" ]; then
      node "$SELF_DIR/scripts/reach-status.mjs" "$@"
    else
      run_reachctl status "$@"
    fi
    ;;
  version|--version|-v)
    shift
    run_reachctl version "$@"
    ;;
  bugreport)
    shift
    bug_tmp="$(mktemp)"
    bug_err_tmp="$(mktemp)"
    if run_reachctl bugreport "$@" >"$bug_tmp" 2>"$bug_err_tmp"; then
      cat "$bug_tmp"
      [ -s "$bug_err_tmp" ] && cat "$bug_err_tmp" >&2 || true
      rm -f "$bug_tmp" "$bug_err_tmp"
    else
      rm -f "$bug_tmp" "$bug_err_tmp"
      run_bugreport_fallback "$@"
    fi
    ;;
  help|--help|-h)
    print_help
    ;;
  *)
    # Default behavior: forward to reachctl for compatibility.
    run_reachctl "$cmd" "${@:2}"
    ;;
esac
